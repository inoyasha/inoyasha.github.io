<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我的使用工具地址]]></title>
    <url>%2F2019%2F08%2F25%2Fundefined.html</url>
    <content type="text"><![CDATA[将一些会经常用到的一些工具统一整理，方便使用。系统设计架构图图片素材在线格式化在线文件大小转换uuid在线生成idea注册码css button样式在线cron表达式在线json表达式]]></content>
      <categories>
        <category>sorting</category>
      </categories>
      <tags>
        <tag>资料整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS第四周]]></title>
    <url>%2F2019%2F04%2F14%2Farts-fourth-week.html</url>
    <content type="text"><![CDATA[ARTS第四周每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）Algorithm来自leecode的一个简单的算法题——罗马数转整数。解题思路先用罗马数字的字母作为key值放到一个map中，然后将目标罗马数按照&quot;&quot;分解成一个字符串数组。遍历字符串数组，根据key获取对应的值进行相加，当满足一下条件时:对其减去其相差值的2倍即可。以上的做法，需要逻辑判断6次。代码看着不是很优雅。后面看了下评论，发现其实是解题没有充分思考。通常情况下，罗马数字中小的数字在大的数字的右边。除了以上几种情况，如果当前字符代表的值不小于其右边，就加上该值；否则就减去该值。下面给出两种的代码，具体请看我的github.ReviewThis week costs a lot of time to read a article that introduct some new frameworks to follow in 2019 and expression a lot of review to this.react.jsvue.jsjquerykotlinElixir and Phoenix.GraphQLIn fact,i understand this technology a smaller part.Because of useing these less.but i approval view of author.As a developer, it is important to stay up to date with current technological developments as much as possible.憋了半天，还是词穷。我们在工作之外还是要了解一些更新在我们身边的技术，了解其利弊，对于日后的工作可能也会有帮助，它能开阔我们的眼界，当我们遇到技术难题时，也可能帮我们更好的扩展思路。但是其实主要的还是基础知识的把握，因为无论是哪种前端还是后端的技术，都离不开基础的东西。比如说vue.js 我觉得还是依赖于j原生的javascript。所以我们了解新技术，但是也要补充自己的基础知识，这样才能在以后的竞争中站的更稳。Tips最近在看极客时间的视频课程——玩转Git三剑客。里面有一些小技巧。配置最小配置。1234git config --global user.emal xxx@xxx.comgit config --glabal user.name xxx``` - git 重命名git rename xx xxx.text12- git 将新文件提交到暂存区git add 新文件1234- git 将修改的文件,删除的文件添加到暂存区```code git add -ugit 有三个对象1、commit （每次提交会生成一个commit对象。是一个uuid）2、tree （类似文件目录树）3、blob （具体的文件存储）Share分享下最近糟糕的经历。最近leader让我负责一个项目，并把控项目的进度，说实话这个是我第一次把控项目进度。我先使用project(第一次使用)做了一下简单的工期计划，在我预想中，这个工期是可以完成的。但是后续发生了一些不可控的问题。其中一个人没怎么写过页面，但是考虑到页面比较简单，我把这项工作交给他，做到后面的效果和实际的效果差距较大。并且没有及时和领导反馈。导致后面的工作要加班来完成。现在对于这个事情还是比较迷茫，感觉没有抓住重点，所以先记录下并总结几点。当遇到问题的时候，及时和领导反馈，让其协调其他人员。不要让不可控因素持续下去。做好规划，并尽量详尽的给出可能的]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ARTS第三周]]></title>
    <url>%2F2019%2F04%2F06%2Farts-three-week.html</url>
    <content type="text"><![CDATA[ARTS第三周每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）Algorithm来自leecode的一个简单的算法题——回文数。思路：看到题目的时候，想将找一个数据进行按位数进行拆分成为一个数字，然后对于数组的元素来达到目的。12345678910111213141516eg:121[1,2,1] 数组的长度为3，则比较数组中索引为0/2的数字是否相等。如果是数组的长度为5，则需要索引为0/4.1/3的数字是否分别相等。如果为偶数，则仅仅当数组中所有的元素都相同的时候，这个数为回文数。拆分的代码如下: public static List&lt;Integer&gt; splitNum(int target) &#123; List&lt;Integer&gt; split = new ArrayList&lt;&gt;(); int temp = target; while (temp != 0) &#123; int number = temp % 10; split.add(number); temp = temp / 10; &#125; return split; &#125;在继续的过程中，发现其实可以参考下上周做的算法题——整数反转的思路然后变通下。我们发现当整数为负数时，这个数是不可能为回文数的。那么仅仅考虑正整数的情况。当目标数为正整数时，我们可以采用整数反转的形式，将数字反转过来，如果反转过来的数字和目标数字相同，那么这个数就是我们要的回文数。代码如下：123456789101112131415161718public static boolean isPlindrome(int target) &#123; if (target &gt; 0) &#123; int reverse = reverse(target); return reverse == target; &#125; return false; &#125; public static int reverse(int target) &#123; long reverse = 0; while (target != 0) &#123; reverse = 10 * reverse + target % 10; target /= 10; &#125; reverse = (reverse &gt; Integer.MAX_VALUE || reverse &lt; Integer.MIN_VALUE) ? 0 : reverse; return (int) reverse; &#125;Review这周review的内容来自于Medium的一篇文章——怎么使用html、css和js简单的构建桌面应用之前也见到过其他的项目使用nodejs构建桌面的客户端。也一直没有详细的了解过，文中作者一个前端框架——Electron,这个框架使用html、css和js构建桌面项目并能够在多个平台上使用。Elactorn分为两个进程进行工作。一个是主进程，一个是渲染进程，主进程只有一个，二渲染进程是存在多个的，并且相互不会影响。安装npm依赖包。npm install -g electron-forge初始化应用。初始化的时间比较长，请耐心等待，我就卡在install npm Dependencies 好久.electron-forge init simple-desktop-app-electronjs启动应用12cd simple-desktop-app-electronjsnpm start应用打包npm run package -- --platform=&lt;platform&gt; arch=&lt;architecture&gt;其他的可以参考Elactron官网了解。——ElactronTipsSpringboot使用多数据源碰到了一个迁移数据的功能。使用springboot创建多数据源。配置数据源基本信息。` 读取配置信息12345678910111213import lombok.Data;@Datapublic class DbBean &#123; private String driverClassName; private String dataUsername; private String dataPassword; private String url;&#125;1234567@Component@ConfigurationProperties(prefix = "cms.content-migrate")@Datapublic class CmsMigrateTables &#123; private List&lt;String&gt; tables;&#125;创建多数据源1234567891011121314151617181920212223242526272829303132@Configurationpublic class DataSourceBeans &#123; private DataSourceConfiguration dataSourceConfiguration; @Autowired public DataSourceBeans(DataSourceConfiguration dataSourceConfiguration) &#123; this.dataSourceConfiguration = dataSourceConfiguration; &#125; @Bean("sourceDataSource") public DataSource sourceDataSource() &#123; DbBean sourceDb = dataSourceConfiguration.getSource(); DataSourceBuilder&lt;?&gt; dataSourceBuilder = DataSourceBuilder.create(); dataSourceBuilder.username(sourceDb.getDataUsername()); dataSourceBuilder.password(sourceDb.getDataPassword()); dataSourceBuilder.driverClassName(sourceDb.getDriverClassName()); dataSourceBuilder.url(sourceDb.getUrl()); return dataSourceBuilder.build(); &#125; @Bean("targetDataSource") public DataSource targetDataSource() &#123; DbBean targetDb = dataSourceConfiguration.getSource(); DataSourceBuilder&lt;?&gt; dataSourceBuilder = DataSourceBuilder.create(); dataSourceBuilder.username(targetDb.getDataUsername()); dataSourceBuilder.password(targetDb.getDataPassword()); dataSourceBuilder.driverClassName(targetDb.getDriverClassName()); dataSourceBuilder.url(targetDb.getUrl()); return dataSourceBuilder.build(); &#125;获取数据源以后，可以使用jdbcTemplate或者spring-jpa进行数据库查询了。以上配置基于springboot2.1.4配置。参考文章:Spring Boot多数据源配置与使用share分享一个画拓扑图的工具吧。近期有一个画拓扑图的需求。使用图表可以使用echart或者jtopo等工具。后面比较了了一下，根据go.js画拓扑图是比较专业的。go-js的官网，如有需要的小伙伴可以参考下。写到最后的话这已经我打卡ARTS的第三周了，从接触ARTS到不断学习的过程，内心还是有些愉悦的，但是我做的还不是特别的好，希望在日后我也可以写出高质量的文章，并能够坚持下去，不断前行。加油！]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ARTS第二周]]></title>
    <url>%2F2019%2F03%2F31%2Farts-second-week.html</url>
    <content type="text"><![CDATA[ARTS第二周每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTSAlgorithm题目来自于leecode的整数反转。给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。解答。刚开始本来想着将Integer转成String然后在利用String的反转来做。但是还是利用了java的工具类。而且在处理起来也比较繁琐。并不太好处理越界的情况。我们知道12345123%10=3;123/10=12;12%10=2;12/10=1;1/10=0;我们每次对10取余数都能获取这个数的最后一位，然后在将目标数除以10获取这个数的n-1位。那我们是不是可以利用这个规律（3*10 + 2）10 +1=321来获得我们的结果呢。所以for循环重复上面的操作即可。具体代码如下：123456while (target != 0) &#123; reverse = 10 * reverse + target % 10; target /= 10; &#125; reverse = (reverse &gt; Integer.MAX_VALUE || reverse &lt; Integer.MIN_VALUE) ? 0 : reverse; return (int) reverse;Reviewreview看了一个关于git的一篇文章——如何成为一个git专家。How to become a Git expert。作者主要讲解了两个问题。当提交代码时，出错怎么处理。比如说当你有6个文件进行提交的时候，但是最后你只是提交了5个，虽然可以在后面重新添加到git上并提交到本地，但是这次的提交看着并不是很优美。这个时候我们可以借助git commit --amend -m “New commit message” 来修改这次提交。但是请注意amend命令适合用于本地的修改，如果在远端仓库上使用，可能会导致代码的紊乱。当提交记录毕竟混乱的时候，应该如何处理。我们知道git是一个版本控制工具，大部分的时候都是多人进行提交代码，当你有一个需求，已经确定大概需要10天左右才能完成，而在这个期间会有其他的人提交代码。保持远端和本地库的做法是一个比较好的方式，这能减少代码合并引起的冲突。作者在后续的内容中主要讲解了如何使用rebase命令来解决这个问题。具体的提交流程作者使用一个小例子进行了讲解。思考。在我看来rebase命令其实构建了git-flow的一个流程。国内大部分企业使用git的时候都可能在使用这个流程。详细可以看下这篇文章——git-flow 的工作流程。rebase能让代码的提交流程看着更加清晰。并且在分支合并的时候可以进行coding的review过程。Tips使用shell 脚本执行orientdb etl工具.orientdb 有自己的etl工具。它是通过sh 脚本来进行数据迁移的。orientdb进行抽取的时候，大部分的使用场景还是全量迁移数据，但是当数据量比较大的时候，全量的迁移就会影响应用系统的正常使用。在每次进行抽取的时候，现将抽取时间放到一个文件中，然后执行orientdb脚本的时候，将时间通过sed -i &quot;s/xx/xx&quot; filepath的形式，将对应的json文件中的sql查询进行替换，查询增量数据，执行完抽取后，将最新的时间更新到配置文件中。此次使用了sh 脚本读取配置文件的配置1234采用了eval的方式读取while read line;do eval "$line"done &lt; configconfig是读取文件的路径.其他的读取方式请参考——linux shell 读取配置文件Share此次分享说下我在我的Centos7环境上配置maven引发的问题。场景。Centos上搭建idea环境，配置maven环境变量。在/etc/profile文件中添加了MAVEM_HOME=/opt/xxx/maven/ 然后配置到了$PATH上，并执行了source /etc/profile命令，让其生效，当时试了一下mvn -v，好用了，觉得大功告成了。这为了后面的悲剧做了铺垫。出现的问题。当我将电脑重启了以后，发现使用我的账户登录以后，使用终端显示-base-4.1$这样的显示，切换成root账户登录的时候显示正常。解决。后来谷歌查询了一下有多个方式可以解决这个事情。1、centos在创建新用户的时候，会将/etc/skel/下面的配置复制到新创建用户的配置中取，这个问题的出现是.bash等文件丢失引起的，将文件重新复制回来即可。2、vi ~/.bash_profile 然后往文件中添加如下内容export PS1=’[\u@\h \W]\$’出现的原因。但是配置maven的时候在maven的配置目录多配置了一个/，导致Centos的环境变量出现了紊乱导致。重新复制了配置以后，在将环境变量多余的/去除掉。问题解决。]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ARTS第一周]]></title>
    <url>%2F2019%2F03%2F23%2Farts-first-week.html</url>
    <content type="text"><![CDATA[ARTS第一周每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）Algorithm题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。作答使用双层for循环，将两个数组对应的元素进行相加，如果结果等于目标值，则获取对应的数组下标。12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int len = nums.length; for (int i = 0; i &lt; len; i++) &#123; for (int j = 0; j &lt; i + 1; j++) &#123; if (nums[i] + nums[j] == target &amp;&amp; i != j) &#123; return new int[]&#123;i, j&#125;; &#125; &#125; &#125; return null; &#125;&#125;ReviewSpring5.0官方文档之前在使用spring时，遇到问题直接百度/googole查询资料，有的时候找到资料的时候就借鉴使用了，也没有深究其中的原理。趁着ARTS的机会，阅读了一下spring5.0的官方文档。Spring Web MVC 的名字来源于spring项目中的第一个模块 spring-webmvc,更多被熟知为”Spring MVC”。于Spring Web MVC并行的Spring WebFlux的web框架也是来源于源代码模块中的spring-webflux。DispatcherServlet servlet分发器。它和其他的web框架一样，被设计为一个围绕前端控制器的一个主要的servlet，它为请求处理提供了分享算法，但是实际的工作是由委托的组建所完成，它相当于一个枢纽，当请求来了以后告诉这个请求应该谁去处理，然后当请求完成以后，应该交由那个模块进行解析。DispatcherServlet的注册方式有两种，一种是使用java代码进行注册，一种是使用web.xml进行注册。Tips这周在处理问题的时候，需要在将本地服务器的文件上传到其他的服务器上。使用两种方式来处理文件的上传，一种是带有返回值的处理，二另一种只返回http请求状态码。带有返回值的文件上传123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 上传文件 * @param serverUrl 请求地址 * @param file 上传的文件 * @param params 参数 * @return */ public static String uploadFileByPost(String serverUrl, File file, Map&lt;String, String&gt; params) throws IOException &#123; String respStr = null; CloseableHttpClient httpclient = HttpClients.createDefault(); try &#123; HttpPost httppost = new HttpPost(serverUrl); // 获取bin文件 FileBody binFileBody = new FileBody(file); MultipartEntityBuilder multipartEntityBuilder = MultipartEntityBuilder .create(); multipartEntityBuilder .setMode(HttpMultipartMode.BROWSER_COMPATIBLE); multipartEntityBuilder.setCharset(Consts.UTF_8); multipartEntityBuilder.addPart(file.getName(), binFileBody); HttpEntity reqEntity = multipartEntityBuilder.build(); httppost.setEntity(reqEntity); CloseableHttpResponse response = httpclient.execute(httppost); HttpEntity resEntity = response.getEntity(); if (Objects.nonNull(resEntity)) &#123; respStr = EntityUtils .toString(resEntity, Charset.forName(&quot;UTF-8&quot;)); EntityUtils.consume(resEntity); &#125; &#125; catch (ClientProtocolException e) &#123; logger.error(&quot;上传文件失败,client 协议异常&quot;); throw e; &#125; catch (IOException e) &#123; logger.error(&quot;上传文件失败,IO异常&quot;); throw e; &#125; catch (NullPointerException ex) &#123; logger.error(&quot;接口返回异常&quot;); throw ex; &#125; finally &#123; try &#123; httpclient.close(); &#125; catch (IOException e) &#123; logger.error(&quot;关闭httpClient异常&quot;, e); &#125; &#125; return respStr; &#125;只返回状态值的上传/** * 上传文件使用httppost请求 * @param file 文件 * @param params 参数 * @return */ public static int uploadByPost(String url, File file, Map&lt;String, String&gt; params) { PostMethod filePost = new PostMethod(url); HttpClient client = new HttpClient(); if (Objects.nonNull(params)) { params.forEach((k, v) -&gt; { filePost.setParameter(k, v); }); } try { Part[] parts = { new FilePart(file.getName(), file) }; filePost.setRequestEntity( new MultipartRequestEntity(parts, filePost.getParams())); client.getHttpConnectionManager().getParams() .setConnectionTimeout(5000); int status = client.executeMethod(filePost); if (status == HttpStatus.SC_OK) { logger.debug(&quot;上传文件成功!&quot;); } else { logger.debug(&quot;上传文件失败!&quot;); } return status; } catch (FileNotFoundException e) { logger.error(&quot;上传文件没有找到!&quot;, e); } catch (HttpException e) { logger.error(&quot;网络连接异常!&quot;, e); } catch (IOException e) { logger.error(&quot;IO 异常&quot;, e); } finally { filePost.releaseConnection(); } return 0; } share很久以前的一个需求，需要在ueditor(1.3.6版本上)添加一个一键排版的功能，具体的思路是点击排版按钮的时候ueditor的选取文字按照一个固定的样式进行格式化。其实就是编写ueditor的一个过滤规则。具体可以参考：ueditor1.3.6 扩展插件(一键排版)]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[阿里巴巴开发手册]]></title>
    <url>%2F2019%2F02%2F20%2Falibaba-development-manual.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>books</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【转载】CentOS7下安装chrome浏览器]]></title>
    <url>%2F2019%2F02%2F17%2Finstall-chrome-browser-under-centos-7.html</url>
    <content type="text"><![CDATA[Centos下安装chrome浏览器。从google官网下载google chrome安装包选择linux系统，并下载google-chrome-stable_current_x86_64.使用root权限进行安装rpm -ivh google-chrome-stable_current_x86_64.rpm安装错误123 错误：依赖检测失败： lsb &gt;= 4.0 被 google-chrome-stable-54.0.2840.59-1.x86_64 需要 libXss.so.1()(64bit) 被 google-chrome-stable-54.0.2840.59-1.x86_64 需要安装依赖包123yum install pax*yum install redhat-lsb*yum -y install libXss*依赖检测失败yum install libappindicato再次安装rpm软件包rpm -ivh google-chrome-stable_current_x86_64.rpm################################# [100%]12正在升级/安装... 1:google-chrome-stable-54.0.2840.59################################# [100%]至此，google chrome安装成功！此时应用程序中已经有Google Chrome标志啦！ps: chrome默认是不能给root用户运行的。右击打开属性在命令后面加上下面内容--no-sandbox原文:CentOS7下安装chrome浏览器]]></content>
  </entry>
  <entry>
    <title><![CDATA[【转载】CentOS 7 下安装Lantern（VPN）]]></title>
    <url>%2F2019%2F02%2F17%2Finstall-lantern-(vpn)-under-centos-7.html</url>
    <content type="text"><![CDATA[在实际的开发过程中，当我们遇到难题时，往往会询问“度娘”来解决问题。但是“度娘”的答案有的时候并不是尽善尽美。这个时候我们通过google来寻找答案。使用google搜索需要翻墙，故使用了lantern这个软件。lantern支持windows、Android以及Ubuntu系统，我本机安装的是Centos7，下面介绍如果在Centos上安装lantern。原理使用alien将Ubuntu的deb包转成rpm安装。结果图安装必备的软件alien123# yum install epel-release# rpm --import http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro# rpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-5.el7.nux.noarch.rpm下载ubuntn的deb包。下载地址转化成rpm包sudo alien -r lantern-installer-64-bit.deb此时会出现：Get Error:“conflicts with file from package filesystem”ps: 我在实际操作时，没有遇到，直接转换成功。安装rpmrebuild12sudo yum install rpmrebuildsudo rpmrebuild -pe lantern-4.0.1-2.x86_64.rpmps: lantern-4.0.1-2.x86_64.rpm 这个是转换成功的rpm包。替换文件(把里面的内容替换成下面的，大约在中间部位)12345678910111213141516171819202122232425(Converted from a deb package by alien version 8.95.)%files#%dir %attr(0755, root, root) &quot;/&quot;#%dir %attr(0755, root, root) &quot;/usr&quot;#%dir %attr(0755, root, root) &quot;/usr/bin&quot;%attr(0777, root, root) &quot;/usr/bin/lantern&quot;#%dir %attr(0755, root, root) &quot;/usr/lib&quot;%dir %attr(0755, root, root) &quot;/usr/lib/lantern&quot;%attr(0644, root, root) &quot;/usr/lib/lantern/.packaged-lantern.yaml&quot;%attr(0644, root, root) &quot;/usr/lib/lantern/lantern-binary&quot;%attr(0755, root, root) &quot;/usr/lib/lantern/lantern.sh&quot;%attr(0644, root, root) &quot;/usr/lib/lantern/lantern.yaml&quot;#%dir %attr(0755, root, root) &quot;/usr/share&quot;#%dir %attr(0755, root, root) &quot;/usr/share/applications&quot;%attr(0644, root, root) &quot;/usr/share/applications/lantern.desktop&quot;#%dir %attr(0755, root, root) &quot;/usr/share/doc&quot;%dir %attr(0755, root, root) &quot;/usr/share/doc/lantern&quot;%doc %attr(0644, root, root) &quot;/usr/share/doc/lantern/changelog.gz&quot;%doc %attr(0644, root, root) &quot;/usr/share/doc/lantern/copyright&quot;#%dir %attr(0755, root, root) &quot;/usr/share/icons&quot;#%dir %attr(0755, root, root) &quot;/usr/share/icons/hicolor&quot;#%dir %attr(0755, root, root) &quot;/usr/share/icons/hicolor/128x128&quot;#%dir %attr(0755, root, root) &quot;/usr/share/icons/hicolor/128x128/apps&quot;%attr(0644, root, root) &quot;/usr/share/icons/hicolor/128x128/apps/lantern.png&quot;%changelog以上替换文件是执行了sudo rpmrebuild -pe lantern-4.0.1-2.x86_64.rpm 重新构建了rpm包时，替换的。安装sudo rpm -i /root/rpmbuild/RPMS/x86_64/lantern-4.0.1-2.x86_64.rpmlantern-4.0.1-2.x86_64.rpm 这个rpm包时重新构建生成的。会出现错误(实际安装的时候，暂时没有遇到过)sudo yum install libappindicator-gtk3复制sh文件到根目录cp /usr/lib/lantern/lantern.sh ~./lantern.sh设置开机启动12345vi /etc/rc.d/rc.local把/usr/lib/lantern/lantern.sh 添加进去就可以了，保存退出。ps: 在实际操作的时候，不要着急，仔细完成每个步骤，相信就会成功。原文：CentOS 7 下安装Lantern（VPN）]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【装载】centos 7 安装 恢复windows引导项]]></title>
    <url>%2F2019%2F02%2F17%2Fcentos-7-installation-restores-windows-boot-item.html</url>
    <content type="text"><![CDATA[在电脑Windows10系统上安装Centos7，安装后找不到Windows7引导菜单。原因是CentOS 7已采用新式的grub2系统，所以需要进入/boot/grub2目录后使用vi编辑grub.cfg文件。解决方法一：修改Centos 7的Grub2引导，添加Windows的启动项123456781.sudo vi /boot/grub2/grub.cfg2.找到 ### BEGIN /etc/grub.d/30_os-prober ### 在后面添加 menuentry &quot;Windows 10 (loader) (on /dev/sda1)&quot; &#123; insmod ntfs set root=(hd0,1) #由于我的windows安装在硬盘的C盘，故（hd0,1) chainloader +1 &#125;系统自动检测是否有其他系统grub2-mkconfig -o /boot/grub2/grub.cfg `Linux只能认识Ext3/4，fat32格式，如果Windows是NTFS格式磁盘分区，Grub2将无法识别。步骤如下:安装epel-release.noarch:yum install epel-release.noarch安装ntfs-3g用于识别ntfs分区yum install ntfs-3g重新生成引导项grub2-mkconfig -o /boot/grub2/grub.cfg重新启动系统。原文：安装centos后无法引导启动windows7的解决方法]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SourceTree 免登录跳过初始设置（转载）]]></title>
    <url>%2F2019%2F02%2F16%2Fsourcetree-logon-free-skip-initial-settings-(reprint).html</url>
    <content type="text"><![CDATA[使用git的时候，有很多的界面管理工具，下面推荐一个比较好用git管理工具——SourceTree.下载地址SourceTree官网SourceTree免登陆的方法SourceTree 安装之后需要使用账号登陆以授权，以前是可以不登陆的，但是现在是强制登陆。虽然是免费授权，但是碰上不可抗力因素，登陆不是很方便，这里记录一下跳过这个初始化的步骤。新建accounts.json文件%LocalAppData%\Atlassian\SourceTree\找到以上目录，查看是否存在accounts.json文件，如果不存在则新建。文件的内容如下123456789101112131415161718192021222324[ &#123; "$id": "1", "$type": "SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity", "Authenticate": true, "HostInstance": &#123; "$id": "2", "$type": "SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount", "Host": &#123; "$id": "3", "$type": "SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount", "Id": "atlassian account" &#125;, "BaseUrl": "https://id.atlassian.com/" &#125;, "Credentials": &#123; "$id": "4", "$type": "SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account", "Username": "", "Email": null &#125;, "IsDefault": false &#125;]文章来源:SourceTree 免登录跳过初始设置]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[转载：Java 获取Linux 的IP地址]]></title>
    <url>%2F2019%2F02%2F03%2Freprint%3A-java-gets-the-ip-address-of-linux.html</url>
    <content type="text"><![CDATA[前言在java web项目中，我们总会有获取服务器ip地址的需求，下面给出获取操作系统ip地址方法。实际编码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144package com.xx.utils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.servlet.http.HttpServletRequest;import java.net.InetAddress;import java.net.NetworkInterface;import java.net.SocketException;import java.net.UnknownHostException;import java.util.Enumeration;/** * Description: * * @author guoyupeng [2018/7/18] */public final class WebToolUtils &#123; /** * 系统os为windows的标志 */ private static final String OS_WINDOWS = &quot;windows&quot;; /** * 获取客户端ip 不知道的ip地址 */ private static final String UNKNOWN_IP = &quot;unknown&quot;; /** * logger */ private static final Logger logger = LoggerFactory.getLogger(WebToolUtils.class); /** * 获取本地ip地址 * * @return */ public static String getLoacalIp() throws UnknownHostException, SocketException &#123; if (isWindowsOs()) &#123; return getLocalHostName(); &#125; else &#123; return getLinuxLocalIp(); &#125; &#125; /** * 是否windows系统 * * @return */ public static boolean isWindowsOs() &#123; boolean isWindows = false; String osName = System.getProperty(&quot;os.name&quot;); if (osName.toLowerCase().indexOf(OS_WINDOWS) &gt; -1) &#123; isWindows = true; &#125; return isWindows; &#125; /** * 获取本机ip地址 * * @return * @throws UnknownHostException 不知道的主机名称异常 */ public static String getLocalHostName() throws UnknownHostException &#123; return InetAddress.getLocalHost().getHostName(); &#125; /** * 获取Linux下的IP地址 * * @return IP地址 * @throws SocketException */ private static String getLinuxLocalIp() throws SocketException &#123; String ip = &quot;&quot;; try &#123; for (Enumeration&lt;NetworkInterface&gt; en = NetworkInterface.getNetworkInterfaces(); en .hasMoreElements(); ) &#123; NetworkInterface intf = en.nextElement(); String name = intf.getName(); if (!name.contains(&quot;docker&quot;) &amp;&amp; !name.contains(&quot;lo&quot;)) &#123; for (Enumeration&lt;InetAddress&gt; enumIpAddr = intf.getInetAddresses(); enumIpAddr .hasMoreElements(); ) &#123; InetAddress inetAddress = enumIpAddr.nextElement(); if (!inetAddress.isLoopbackAddress()) &#123; String ipAddress = inetAddress.getHostAddress().toString(); if (!ipAddress.contains(&quot;::&quot;) &amp;&amp; !ipAddress.contains(&quot;0:0:&quot;) &amp;&amp; !ipAddress.contains(&quot;fe80&quot;)) &#123; ip = ipAddress; logger.debug(&quot;ip地址为：&#123;&#125;&quot;, ipAddress); &#125; &#125; &#125; &#125; &#125; &#125; catch (SocketException ex) &#123; logger.error(&quot;获取ip地址异常&quot;, ex.getMessage()); ip = &quot;127.0.0.1&quot;; &#125; return ip; &#125; /** * 获取用户真实IP地址，不使用request.getRemoteAddr();的原因是有可能用户使用了代理软件方式避免真实IP地址, * &lt;p&gt; * 可是，如果通过了多级反向代理的话，X-Forwarded-For的值并不止一个，而是一串IP值，究竟哪个才是真正的用户端的真实IP呢？ * 答案是取X-Forwarded-For中第一个非unknown的有效IP字符串。 * &lt;p&gt; * 如：X-Forwarded-For：192.168.1.110, 192.168.1.120, 192.168.1.130, * 192.168.1.100 * &lt;p&gt; * 用户真实IP为： 192.168.1.110 * * @param request * @return */ public static String getIpAddress(HttpServletRequest request) &#123; String ip = request.getHeader(&quot;x-forwarded-for&quot;); if (ip == null || ip.length() == 0 || UNKNOWN_IP.equalsIgnoreCase(ip)) &#123; ip = request.getHeader(&quot;Proxy-Client-IP&quot;); &#125; if (ip == null || ip.length() == 0 || UNKNOWN_IP.equalsIgnoreCase(ip)) &#123; ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;); &#125; if (ip == null || ip.length() == 0 || UNKNOWN_IP.equalsIgnoreCase(ip)) &#123; ip = request.getHeader(&quot;HTTP_CLIENT_IP&quot;); &#125; if (ip == null || ip.length() == 0 || UNKNOWN_IP.equalsIgnoreCase(ip)) &#123; ip = request.getHeader(&quot;HTTP_X_FORWARDED_FOR&quot;); &#125; if (ip == null || ip.length() == 0 || UNKNOWN_IP.equalsIgnoreCase(ip)) &#123; ip = request.getRemoteAddr(); &#125; return ip; &#125;&#125;原文地址：Java 获取Linux 的IP地址]]></content>
      <categories>
        <category>java web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[转载:关于fastjson的@JSONField注解的一些问题(详解)]]></title>
    <url>%2F2019%2F02%2F02%2Freprint%3A-some-questions-about-the-%40jsonfield-annotation-of-fastjson-(detailed).html</url>
    <content type="text"><![CDATA[引言在java web项目中，我们接受的前台参数和后台定义的参数不一致的时候，需要我们将字段进行转换，fastjson中有一个@JsonField注解，能够将字段属性和数据库列进行转换。下面说明一下关于fastjson中@JSONFiled注解的一些问题。关于fastjson的@JSONField注解的一些问题(详解)@JSONField 看源码它可以作用于字段和方法上。作用Field@JSONField作用在Field时，其name不仅定义了输入key的名称，同时也定义了输出的名称。但是我在使用中，发现并不如上所说。1@JSONField(name="project_id") private Long ProjectID发现bean 转json的时候并是&quot;project_id&quot;:xxx的形式，json转bean的时候也不会把&quot;project_id&quot;:xx的内容设置到ProjectID的里面。对应的fastjson的版本是1.1.15。作用在setter和getter方法上 这种方式倒是在使用的过程当中符合期望。123456789101112/**bean 转json 时会把bean中的ProjectID转换为project_id */ @JSONField(name="project_id") public Long getProjectID() &#123; return ProjectID; &#125;/**json 转bean 时会把json中的project_id值赋值给projectID*/ @JSONField(name="project_id") public void setProjectID(Long projectID) &#123; ProjectID = projectID; &#125;@JSONField其它用法查看@JSONField注解的源码，除了name可用之外，还有format，serialize，deserialize，serialzeFeatures，parseFeatures可用。format，貌似用在Date类型的字段来格式化时间格式比较有用。serialize和deserialize是布尔类型的，用法为12@JSONField(serialize=false) private Long ProjectID就是在序列化的时候就不包含这个字段了。deserialize与之相反。但是有一点需要注意，我看其它地方说，当字段为final的时候注解放在字段上是不起作用的，这时候应该放在get或set方法上。serialzeFeatures.我用到这个属性，fastjson默认的序列化规则是当你的字段的值为null的时候，它是不会给你序列化这个字段的，例如我有一个这样的需求。1&#123;"fieldName":"project_id","operator":"is not","value":null&#125;一个对象序列化成这样，我的代码如下1234CriteriaVO criteriaVO = new CriteriaVO(); criteriaVO.setFieldName("project_id"); criteriaVO.setOperator("is not"); criteriaVO.setValue(null);默认的它只会序列化为如下结果1&#123;"fieldName":"project_id","operator":"is not"&#125;当然fastjson还是允许你控制一下序列化的规则的。这就用到了SerializerFeature，这个一个枚举，里面有好几个值 ，具体的含义大家有兴趣的可以了解一下,我只是用到了其中一个。12@JSONField(serialzeFeatures=SerializerFeature.WriteMapNullValue)private String value;这样当value的值为null的时候，依然会把它的值序列化出来。也就是下面的样子，这就是我想要的结果1&#123;"fieldName":"project_id","operator":"is not","value":null&#125;`又遇到了另一个问题，当字段类型为int类型时，如12private int start;private int limit;我如果不set值的时候，会序列化为下面这样1"limit":0,"start":0默认为都是0了，而我的目标是如果不设置值的时候，它们不会出现。我是简单地通过把他们的类型改为Integer了。应该有其它通过自定义序列化行为的方式来解决，暂不研究。原文转载: 关于fastjson的@JSONField注解的一些问题(详解)]]></content>
      <categories>
        <category>java web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[转载：几种copyProperties工具类性能比较]]></title>
    <url>%2F2019%2F02%2F02%2Freprint%3A-performance-comparison-of-several-copyproperties-tooling-classes.html</url>
    <content type="text"><![CDATA[前言在coding过程中，难免遇到对象的属性复制，往往我们想到的都是使用apahce的BeanUtils的corpProperties来进行复制，但是它的性能并不仅人意。下面我们来看下几种copyProperties工具类的性能比较。市面上的其他几种属性copy工具springframework的BeanUtilscglib的BeanCopierApache BeanUtils包的PropertyUtils类由于apache BeanUtils的性能存在问题所以使用上面的集中工具来代替工具名称执行1000次耗时10000次100000次10000000次Apache BeanUtils390ms854ms1763ms8408msApache PropertyUtils26ms221ms352ms2663msspring BeanUtils39ms315ms373ms949msCglib BeanCopier64ms144ms171ms309ms结论:Apache BeanUtils的性能最差,不建议使用。Apache PropertyUtils100000次以内性能还能接受,到百万级别性能就比较差了,可酌情考虑。spring BeanUtils和BeanCopier性能较好,如果对性能有特别要求,可使用BeanCopier,不然spring BeanUtils也是可取的。详细的解析过程请到远文章查看:几种copyProperties工具类性能比较]]></content>
      <tags>
        <tag>工具类</tag>
        <tag>copyProperties</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】Spring Boot中使用Swagger2构建强大的RESTful API文档]]></title>
    <url>%2F2019%2F02%2F02%2F%5Breprint%5D-spring-boot-uses-swagger-2-to-build-powerful-restful-api-documents.html</url>
    <content type="text"><![CDATA[前言Swagger是一个Restful风格接口的文档在线自动生成和测试的框架。下面引入swagger官网的一句话。Swagger UI allows anyone — be it your development team or your end consumers — to visualize and interact with the API’s resources without having any of the implementation logic in place. It’s automatically generated from your OpenAPI (formerly known as Swagger) Specification, with the visual documentation making it easy for back end implementation and client side consumption.swagger 官网官网地址使用Spring Boot中使用Swagger2构建RESTful API.由于Spring Boot能够快速开发、便捷部署等特性，相信有很大一部分Spring Boot的用户会用来构建RESTful API。而我们构建RESTful API的目的通常都是由于多终端的原因，这些终端会共用很多底层业务逻辑，因此我们会抽象出这样一层来同时服务于多个移动端或者Web前端。这样一来，我们的RESTful API就有可能要面对多个开发人员或多个开发团队：IOS开发、Android开发或是Web开发等。为了减少与其他团队平时开发期间的频繁沟通成本，传统做法我们会创建一份RESTful API文档来记录所有接口细节，然而这样的做法有以下几个问题：由于接口众多，并且细节复杂（需要考虑不同的HTTP请求类型、HTTP头部信息、HTTP请求内容等），高质量地创建这份文档本身就是件非常吃力的事，下游的抱怨声不绝于耳。随着时间推移，不断修改接口实现的时候都必须同步修改接口文档，而文档与代码又处于两个不同的媒介，除非有严格的管理机制，不然很容易导致不一致现象。为了解决上面这样的问题，本文将介绍RESTful API的重磅好伙伴Swagger2，它可以轻松的整合到Spring Boot中，并与Spring MVC程序配合组织出强大RESTful API文档。它既可以减少我们创建文档的工作量，同时说明内容又整合入实现代码中，让维护文档和修改代码整合为一体，可以让我们在修改代码逻辑的同时方便的修改文档说明。另外Swagger2也提供了强大的页面测试功能来调试每个RESTful API。具体效果如下图所示下面来具体介绍，如果在Spring Boot中使用Swagger2。首先，我们需要一个Spring Boot实现的RESTful API工程，若您没有做过这类内容，建议先阅读Spring Boot构建RESTful API与单元测试添加Swagger2依赖在pom.xml中加入Swagger2的依赖12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;创建Swagger2配置类在Application.java同级创建Swagger2的配置类Swagger2。12345678910111213141516171819202122232425@Configuration@EnableSwagger2public class Swagger2 &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage("com.didispace.web")) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("Spring Boot中使用Swagger2构建RESTful APIs") .description("更多Spring Boot相关文章请关注：http://blog.didispace.com/") .termsOfServiceUrl("http://blog.didispace.com/") .contact("程序猿DD") .version("1.0") .build(); &#125;&#125;如上代码所示，通过@Configuration注解，让Spring来加载该类配置。再通过@EnableSwagger2注解来启用Swagger2。再通过createRestApi函数创建Docket的Bean之后，apiInfo()用来创建该Api的基本信息（这些基本信息会展现在文档页面中）。select()函数返回一个ApiSelectorBuilder实例用来控制哪些接口暴露给Swagger来展现，本例采用指定扫描的包路径来定义，Swagger会扫描该包下所有Controller定义的API，并产生文档内容（除了被@ApiIgnore指定的请求）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@RestController@RequestMapping(value="/users") // 通过这里配置使下面的映射都在/users下，可去除public class UserController &#123; static Map&lt;Long, User&gt; users = Collections.synchronizedMap(new HashMap&lt;Long, User&gt;()); @ApiOperation(value="获取用户列表", notes="") @RequestMapping(value=&#123;""&#125;, method=RequestMethod.GET) public List&lt;User&gt; getUserList() &#123; List&lt;User&gt; r = new ArrayList&lt;User&gt;(users.values()); return r; &#125; @ApiOperation(value="创建用户", notes="根据User对象创建用户") @ApiImplicitParam(name = "user", value = "用户详细实体user", required = true, dataType = "User") @RequestMapping(value="", method=RequestMethod.POST) public String postUser(@RequestBody User user) &#123; users.put(user.getId(), user); return "success"; &#125; @ApiOperation(value="获取用户详细信息", notes="根据url的id来获取用户详细信息") @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long") @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.GET) public User getUser(@PathVariable Long id) &#123; return users.get(id); &#125; @ApiOperation(value="更新用户详细信息", notes="根据url的id来指定更新对象，并根据传过来的user信息来更新用户详细信息") @ApiImplicitParams(&#123; @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long"), @ApiImplicitParam(name = "user", value = "用户详细实体user", required = true, dataType = "User") &#125;) @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.PUT) public String putUser(@PathVariable Long id, @RequestBody User user) &#123; User u = users.get(id); u.setName(user.getName()); u.setAge(user.getAge()); users.put(id, u); return "success"; &#125; @ApiOperation(value="删除用户", notes="根据url的id来指定删除对象") @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long") @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.DELETE) public String deleteUser(@PathVariable Long id) &#123; users.remove(id); return "success"; &#125;&#125;完成上述代码添加上，启动Spring Boot程序，访问：http://localhost:8080/swagger-ui.html 就能看到前文所展示的RESTful API的页面。我们可以再点开具体的API请求，以POST类型的/users请求为例，可找到上述代码中我们配置的Notes信息以及参数user的描述信息，如下图所示。API文档访问与调试在上图请求的页面中，我们看到user的Value是个输入框？是的，Swagger除了查看接口功能外，还提供了调试测试功能，我们可以点击上图中右侧的Model Schema（黄色区域：它指明了User的数据结构），此时Value中就有了user对象的模板，我们只需要稍适修改，点击下方“Try it out！”按钮，即可完成了一次请求调用！此时，你也可以通过几个GET请求来验证之前的POST请求是否正确。相比为这些接口编写文档的工作，我们增加的配置内容是非常少而且精简的，对于原有代码的侵入也在忍受范围之内。因此，在构建RESTful API的同时，加入swagger来对API文档进行管理，是个不错的选择。转载：Spring Boot中使用Swagger2构建强大的RESTful API文档]]></content>
      <categories>
        <category>java web</category>
      </categories>
      <tags>
        <tag>sprintboot</tag>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot2.0版本构建单元测试]]></title>
    <url>%2F2019%2F02%2F02%2Fspringboot-version-2.0-builds-unit-tests.html</url>
    <content type="text"><![CDATA[前言我们在coding的时候，都要对自己的coding进行测试，而对于开发有效的测试不外乎是单元测试了。以往的单元测试我们通过加载配置文件进行测试，但是这样相当于启动了整个项目，于是出现了mock的测试方式。对于mock测试优缺点，可以参考这篇文章——Mock测试-优缺点分析。下面我来介绍下springboot2.0采用mock测试的方法。使用mock的形式测试controller带参数的接口以下为demo代码12345678910111213141516171819202122232425262728293031323334353637383940414243package com.guoyupeng.restapi;import com.guoyupeng.response.ResponseObject;import io.swagger.annotations.Api;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiImplicitParams;import io.swagger.annotations.ApiOperation;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;/** * Description: restful controller * * @author guoyupeng [2018/11/29] */@RestController@RequestMapping("/api")@Api(tags = "rest api demo")public class RestApi &#123; /** * api demo * * @return */ @ApiOperation("rest api demo") @ApiImplicitParams(&#123;@ApiImplicitParam(value = "params", name = "params", required = false)&#125;) @GetMapping("v1/demo") public ResponseObject apiDemo(@RequestParam(name = "params", required = false) String params) &#123; log.debug("rest api demo"); return new ResponseObject("rest api demo"); &#125; /** * rest api log */ private Logger log = LoggerFactory.getLogger(RestApi.class);&#125;带参数的接口下面编写两个方法分别测试传入参数testApiDemoWithParams和没有参数apiDemoNoParam的测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.guoyupeng.restapi;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.mock.web.MockServletContext;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.MvcResult;import org.springframework.test.web.servlet.RequestBuilder;import org.springframework.test.web.servlet.ResultActions;import org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;import org.springframework.test.web.servlet.result.MockMvcResultMatchers;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;/** * Description: rest api demo test * * @author guoyupeng [2018/11/29] */@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = MockServletContext.class)@WebAppConfigurationpublic class RestApiTest &#123; private MockMvc mockMvc; /** * 单元测试启动初始化 */ @Before public void setUp() &#123; mockMvc = MockMvcBuilders.standaloneSetup(new RestApi()).build(); &#125; /** * 测试api demo 不传入参数的形式 * * @throws Exception */ @Test public void apiDemoNoParam() throws Exception &#123; //第一种无参的方式 RequestBuilder requestBuilder = null; requestBuilder = MockMvcRequestBuilders.get("/api/v1/demo"); mockMvc.perform(requestBuilder).andExpect(MockMvcResultMatchers.status().isOk()) .andExpect(MockMvcResultMatchers.content().json("&#123;\"message\":\"rest api demo\"&#125;")); // 第二种无参的方式 MvcResult mvcResult = mockMvc.perform(requestBuilder).andReturn(); int status = mvcResult.getResponse().getStatus(); String resultContent = mvcResult.getResponse().getContentAsString(); Assert.assertEquals(status, 200); Assert.assertEquals(resultContent, "&#123;\"message\":\"rest api demo\"&#125;"); &#125; /** * 传入参数的demo */ @Test public void testApiDemoWithParams() throws Exception &#123; MockHttpServletRequestBuilder requestBuilder = null; requestBuilder = get("/api/v1/demo").param("param","111"); MvcResult result = mockMvc.perform(requestBuilder).andReturn(); int status = result.getResponse().getStatus(); String resultJson = result.getResponse().getContentAsString(); Assert.assertEquals(status, 200); Assert.assertEquals(resultJson, "&#123;\"message\":\"rest api demo\"&#125;"); &#125;&#125;ps 以上代码是我实际测试过的，欢迎大家积极吐槽。]]></content>
      <tags>
        <tag>springboot</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码——隐匿在计算机软硬件背后的语言上]]></title>
    <url>%2F2019%2F02%2F01%2Fcoding---hidden-in-the-language-behind-computer-software-and-hardware.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>books</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[tomcat6优化配置]]></title>
    <url>%2F2019%2F01%2F30%2Ftomcat-6-optimal-configuration.html</url>
    <content type="text"><![CDATA[引言为什么要对tomcat进行优化？tomcat下载的时候的默认配置并不能满足生产环境的要求，这个时候就需要我们根据生产环境的配置对tomcat进行相应的优化。下面介绍的只是对tomcat6优化的配置，如果有问题的地方，请指出，谢谢。优化的方向JVM内存优化1.备份tomcat/bin/catalina.bat文件2.修改catalina.bat文件，在文件的上方添加一下内容1set JAVA_OPTS=%JAVA_OPTS% -server -Xms1024m -Xmx1024m -XX:PermSize=64M -XX:MaxPermSize=128m -XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:D:\Tomcat\apache-tomcat-6.0.29\logs\gc.log如果想要生成堆栈日志需要添加一下内容。12 JAVA_OPTS="%JAVA_OPTS% -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=日志路径"JAVA_OPTS="%JAVA_OPTS% -XX:ErrorFile=日志路径/hs_err_pid%p.log"说明-Xms1024m -Xmx1024m 的数值要保持一致。具体的内存值根据服务器的配置进行修改。-Xloggc:配置的是jvm虚拟机gc的日志。-XX:PermSize=128M 一般配置成初始物理内存的1/64-XX:MaxPermSize=256M 一般配置成物理内存的1/4tomcat配置优化打开tomcat/conf目录 将server.xml文件进行备份,修改server.xml文件，添加如下内容。12&lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-" maxSpareThreads="75" minSpareThreads="25"/&gt;找到Connector标签 修改Connector的内容1234567//上面添加的Executor节点&lt;Connector executor="tomcatThreadPool" port="80" protocol="HTTP/1.1" connectionTimeout="20000" acceptCount="700" maxThreads="600" enableLookups="false" redirectPort="8443" /&gt;acceptCount容许的最大连接数minSpareThreadsTomcat初始化时创建的 socket线程数maxSpareThreadsTomcat连接器的最大空闲socket 线程数maxThreads客户请求最大线程数找到如下节点：123&lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true" xmlValidation="false" xmlNamespaceAware="false"&gt;将标签中的autoDeploy=&quot;true&quot;改成false]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos下jdk bin格式安装]]></title>
    <url>%2F2019%2F01%2F29%2Finstallation-of-jdk-bin-format-under-centos.html</url>
    <content type="text"><![CDATA[前言Cenots下，使用jdk-bin文件安装jdk。下载bin文件并赋予权限1chmod 755 jdk-6u33-linux-i586-rpm.bin执行bin文件1./ jdk-6u33-linux-i586-rpm.bin安装完成以后文件会默认安装在bin所在文件夹的 java /jdk1.6.0_33下.配置环境变量在/etc/profile 中加入：1234JAVA_HOME=/usr/java/jdk1.6.0_33/CLASSPATH=.:$JAVA_HOME/lib.tools.jarPATH=$JAVA_HOME/bin:$PATHexport JAVA_HOME CLASSPATH PATH运行命令使安装生效1source /etc/profile 使配置文件生效验证安装是否成功12javacjava -version]]></content>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat环境下服务器文件句柄耗尽（Too Many Open Files）的问题排查]]></title>
    <url>%2F2019%2F01%2F29%2Fproblem-checking-of-too-many-open-files-in-tomcat-environment.html</url>
    <content type="text"><![CDATA[前言之前遇到过一次句柄数耗尽的一个问题，具体问题如下。查询了一下资料：原因是服务器的文件句柄数不足，导致tomcat启动失败。排除出现场的linux句柄只有50个，而tomcat占用的句柄数应该是超出了这个数值（从需改了linux的句柄数，服务起来了情况进行推断）。参考:tomcat环境下服务器文件句柄耗尽（Too Many Open Files）的问题排查ps: 如果想要查看linux的具体句柄数可以参考下面这篇文章。Linux下查看某进程占用的文件句柄数和线程数]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>问题排查</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos防火墙iptables的启动与关闭]]></title>
    <url>%2F2019%2F01%2F29%2Fstart-and-close-of-iptables-in-centos-firewall.html</url>
    <content type="text"><![CDATA[前言centos（发行版）防火墙默认firewall 没有安装iptables,这样linux的端口都会被禁止访问。关闭centos默认防火墙1234//停止firewall[root@localhost ~]# systemctl stop firewalld.service //禁止firewall开机启动[root@localhost ~]# systemctl disable firewalld.service安装iptables1234567[root@localhost ~]# yum install iptables-services #重启防火墙使配置生效[root@localhost ~]# systemctl restart iptables.service #设置防火墙开机启动[root@localhost ~]# systemctl enable iptables.service #禁止防火墙开机启动[root@localhost ~]# systemctl disable iptables.serviceiptables命令12345678[root@localhost ~]# service iptable status ---查看防火墙状态[root@localhost ~]#servcie iptables stop --临时关闭防火墙[root@localhost ~]#service iptables start --临时启动防火墙[root@localhost ~]#service iptables restart --重启防火墙[root@localhost ~]#chkconfig iptables off --永久关闭防火墙[root@localhost ~]#chkconfig iptables on --永久开启防火墙]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linix 下安装elasticsearch5.x安装中一些问题的解决办法]]></title>
    <url>%2F2019%2F01%2F29%2Fsolutions-to-some-problems-in-installing-elastic-search-5.x-under-linix.html</url>
    <content type="text"><![CDATA[引言最近在学习elk，由于编译安装使用5.2.1版本的elasticsearch，所以遇到了很多问题，下面是一些问题及解决办法。安装下载地址依赖环境jdk1.8linux安装问题root超级用户不能正常启动由于elasticsearch2.0版本以后不能使用root来启动，所以需要创建一个普通用户来启动。123456[root@bogon ~]# groupadd elasticsearch[root@bogon ~]# useradd elasticsearch -g elasticsearch[root@bogon ~]# chown -R elasticsearch.elasticsearch /usr/local/elk/elasticsearch-5.2.1 [root@bogon ~]# su - elasticsearch[elasticsearch@bogon ~]$ cd /usr/local/elk/elasticsearch-5.2.1/bin/[elasticsearch@bogon bin]$ ./elasticsearch由普通用户来启动，则可以正常启动服务。ERROR: bootstrap checks failed问题12max file descriptors [4096] for elasticsearch process likely too low, increase to at least [65536]max number of threads [1024] for user [lishang] likely too low, increase to at least [2048]解决办法。切换到root用户，编辑limits.conf 添加类似如下内容12345678910vi /etc/security/limits.conf 添加如下内容:* soft nofile 65536* hard nofile 131072* soft nproc 2048* hard nproc 4096max number of threads [1024] for user [lish] likely too low, increase to at least [2048]解决：切换到root用户，进入limits.d目录下修改配置文件。123456789vi /etc/security/limits.d/90-nproc.conf 修改如下内容：* soft nproc 1024#修改为* soft nproc 2048max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]解决：切换到root用户修改配置sysctl.conf1234567891011vi /etc/sysctl.conf 添加下面配置：vm.max_map_count=655360并执行命令：sysctl -p然后，重新启动elasticsearch，即可启动成功。转载:elasticsearch5.x安装中一些问题的解决办法]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 免输入用户名密码操作]]></title>
    <url>%2F2019%2F01%2F29%2Fhexo-password-free-operation.html</url>
    <content type="text"><![CDATA[引言hexo部署到github时，会要求你输入用户名密码，每次提交都要输入，肯定让你抓狂吧，下面的2步配置就能把你从痛苦中解救出来。在系统变量中添加一个环境变量：12变量名：HOME变量值：%USERPROFILE%接着在你的用户目录（C:\Users\username）下新建一个叫 _netrc的文件编辑这个文件：123machine github.comlogin usernamepassword password设置好这些后，当你再次部署时，就不用输入用户名和密码了。转载:Hexo免输入密码部署到github]]></content>
      <categories>
        <category>静态博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github 简单命令]]></title>
    <url>%2F2019%2F01%2F29%2Fgithub-simple-command.html</url>
    <content type="text"><![CDATA[引言github是一个基于git的代码托管平台，付费用户可以建私人仓库，我们一般的免费用户只能使用公共仓库，也就是代码要公开。 Github 由Chris Wanstrath, PJ Hyett 与Tom Preston-Werner三位开发者在2008年4月创办。迄今拥有59名全职员工，主要提供基于git的版本托管服务。本地初始化git1git init添加本地文件1git add 文件名提交到本地仓库1git commit -m &quot;first commit&quot; 提交并添加注释将本地仓库和远程仓库关联1git remote add origin https://github.com/inoyasha/test.git推送到远程仓库12// 推到github分支上git push -u origin master]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建之在文章中插入图片(转载)]]></title>
    <url>%2F2019%2F01%2F25%2Fthe-hexo-blog-is-built-to-insert-pictures-in-the-article-(reprint).html</url>
    <content type="text"><![CDATA[在写文章时，常常有配图说明的需求。Hexo有多种图片插入方式，可以将图片存放在本地引用或者将图片放在CDN上引用。本地引用绝对路径当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。1![](/images/image.jpg)图片既可以在首页内容中访问到，也可以在文章正文中访问到。相对路径图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。1post_asset_folder: true将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。1![](image.jpg)上述是markdown的引用方式，图片只能在文章中显示，但无法在首页中正常显示。如果希望图片在文章和首页中同时显示，可以使用标签插件语法。1&#123;% asset_img image.jpg This is an image %&#125;CDN引用除了在本地存储图片，还可以将图片上传到一些免费的CDN服务中。比如Cloudinary提供的图片CDN服务，在Cloudinary中上传图片后，会生成对应的url地址，将地址直接拿来引用即可。原文地址:Hexo博客搭建之在文章中插入图片]]></content>
      <categories>
        <category>静态博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java环境变量的配置(windows环境)]]></title>
    <url>%2F2019%2F01%2F25%2Fconfiguration-of-java-environment-variables-(windows-environment).html</url>
    <content type="text"><![CDATA[引言这里介绍如果在windows环境配置java环境变量。windows配置java环境变量官网安装java jdk配置环境变量1.新建系统环境变量JAVA_HOME。 我的电脑-属性-高级系统设置-环境变量-新建系统变量。1JAVA_HOME=JDK安装路径2、新建系统环境变量。CLASSPATH12// 配置类库文件的位置CLASSPATH = .;%JAVA_HOME%\lib;%JAVA_HOME%\jre\lib;3、编辑PATH变量。在PATH的最前面配置添加下面一句话。12//JDK 命令文件的位置%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;检验配置是否成功。&nbsp;&nbsp;&nbsp;&nbsp;使用以下命令检验配置是否成功。12javacjava -version]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis 拦截器的使用]]></title>
    <url>%2F2019%2F01%2F24%2Fuse-of-mybatis-interceptor.html</url>
    <content type="text"><![CDATA[引言拦截器的一个作用就是我们可以拦截某些方法的调用，我们可以选择在这些被拦截的方法执行前后加上某些逻辑，也可以在执行这些被拦截的方法时执行自己的逻辑而不再执行被拦截的方法。Mybatis拦截器设计的一个初衷就是为了供用户在某些时候可以实现自己的逻辑而不必去动Mybatis固有的逻辑。打个比方，对于Executor，Mybatis中有几种实现：BatchExecutor、ReuseExecutor、SimpleExecutor和CachingExecutor。这个时候如果你觉得这几种实现对于Executor接口的query方法都不能满足你的要求，那怎么办呢？是要去改源码吗？当然不。我们可以建立一个Mybatis拦截器用于拦截Executor接口的query方法，在拦截之后实现自己的query方法逻辑，之后可以选择是否继续执行原来的query方法。定义拦截器对于拦截器Mybatis为我们提供了一个Interceptor接口，通过实现该接口就可以定义我们自己的拦截器。我们先来看一下这个接口的定义：12345678910111213package org.apache.ibatis.plugin; import java.util.Properties; public interface Interceptor &#123; Object intercept(Invocation invocation) throws Throwable; Object plugin(Object target); void setProperties(Properties properties); &#125;上面的接口我们可以看到有三个方法。intercept,plugin,setProperties。plugin。拦截器用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理。intercept。实际拦截时执行的方法。setProperties。为拦截器配置属性。对于plugin方法而言，其实Mybatis已经为我们提供了一个实现。Mybatis中有一个叫做Plugin的类，里面有一个静态方法wrap(Object target,Interceptor interceptor)，通过该方法可以决定要返回的对象是目标对象还是对应的代理。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package org.apache.ibatis.plugin; import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Set; import org.apache.ibatis.reflection.ExceptionUtil; public class Plugin implements InvocationHandler &#123; private Object target; private Interceptor interceptor; private Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap; private Plugin(Object target, Interceptor interceptor, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) &#123; this.target = target; this.interceptor = interceptor; this.signatureMap = signatureMap; &#125; public static Object wrap(Object target, Interceptor interceptor) &#123; Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor); Class&lt;?&gt; type = target.getClass(); Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap); if (interfaces.length &gt; 0) &#123; return Proxy.newProxyInstance( type.getClassLoader(), interfaces, new Plugin(target, interceptor, signatureMap)); &#125; return target; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; try &#123; Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass()); if (methods != null &amp;&amp; methods.contains(method)) &#123; return interceptor.intercept(new Invocation(target, method, args)); &#125; return method.invoke(target, args); &#125; catch (Exception e) &#123; throw ExceptionUtil.unwrapThrowable(e); &#125; &#125; private static Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) &#123; Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts.class); if (interceptsAnnotation == null) &#123; // issue #251 throw new PluginException("No @Intercepts annotation was found in interceptor " + interceptor.getClass().getName()); &#125; Signature[] sigs = interceptsAnnotation.value(); Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = new HashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;(); for (Signature sig : sigs) &#123; Set&lt;Method&gt; methods = signatureMap.get(sig.type()); if (methods == null) &#123; methods = new HashSet&lt;Method&gt;(); signatureMap.put(sig.type(), methods); &#125; try &#123; Method method = sig.type().getMethod(sig.method(), sig.args()); methods.add(method); &#125; catch (NoSuchMethodException e) &#123; throw new PluginException("Could not find method on " + sig.type() + " named " + sig.method() + ". Cause: " + e, e); &#125; &#125; return signatureMap; &#125; private static Class&lt;?&gt;[] getAllInterfaces(Class&lt;?&gt; type, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) &#123; Set&lt;Class&lt;?&gt;&gt; interfaces = new HashSet&lt;Class&lt;?&gt;&gt;(); while (type != null) &#123; for (Class&lt;?&gt; c : type.getInterfaces()) &#123; if (signatureMap.containsKey(c)) &#123; interfaces.add(c); &#125; &#125; type = type.getSuperclass(); &#125; return interfaces.toArray(new Class&lt;?&gt;[interfaces.size()]); &#125; &#125;Plugin的wrap方法。它根据当前的Interceptor上面的注解定义哪些接口需要拦截，然后判断当前目标对象是否有实现对应需要拦截的接口，如果没有则返回目标对象本身，如果有则返回一个代理对象。而这个代理对象的InvocationHandler正是一个Plugin。所以当目标对象在执行接口方法时，如果是通过代理对象执行的，则会调用对应InvocationHandler的invoke方法，也就是Plugin的invoke方法。所以接着我们来看一下该invoke方法的内容。这里invoke方法的逻辑是：如果当前执行的方法是定义好的需要拦截的方法，则把目标对象、要执行的方法以及方法参数封装成一个Invocation对象，再把封装好的Invocation作为参数传递给当前拦截器的intercept方法。如果不需要拦截，则直接调用当前的方法。Invocation中定义了定义了一个proceed方法，其逻辑就是调用当前方法，所以如果在intercept中需要继续调用当前方法的话可以调用invocation的procced方法。这就是Mybatis中实现Interceptor拦截的一个思想，如果用户觉得这个思想有问题或者不能完全满足你的要求的话可以通过实现自己的Plugin来决定什么时候需要代理什么时候需要拦截。以下讲解的内容都是基于Mybatis的默认实现即通过Plugin来管理Interceptor来讲解的。对于实现自己的Interceptor而言有两个很重要的注解，一个是@Intercepts，其值是一个@Signature数组。@Intercepts用于表明当前的对象是一个Interceptor，而@Signature则表明要拦截的接口、方法以及对应的参数类型。来看一个自定义的简单Interceptor：1234567891011121314151617181920212223242526272829303132333435363738package com.tiantian.mybatis.interceptor; import java.sql.Connection;import java.util.Properties; import org.apache.ibatis.executor.Executor;import org.apache.ibatis.executor.statement.StatementHandler;import org.apache.ibatis.mapping.MappedStatement;import org.apache.ibatis.plugin.Interceptor;import org.apache.ibatis.plugin.Intercepts;import org.apache.ibatis.plugin.Invocation;import org.apache.ibatis.plugin.Plugin;import org.apache.ibatis.plugin.Signature;import org.apache.ibatis.session.ResultHandler;import org.apache.ibatis.session.RowBounds; @Intercepts( &#123; @Signature(method = "query", type = Executor.class, args = &#123; MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class &#125;), @Signature(method = "prepare", type = StatementHandler.class, args = &#123; Connection.class &#125;) &#125;)public class MyInterceptor implements Interceptor &#123;public Object intercept(Invocation invocation) throws Throwable &#123; Object result = invocation.proceed(); System.out.println("Invocation.proceed()"); return result;&#125;public Object plugin(Object target) &#123; return Plugin.wrap(target, this);&#125;public void setProperties(Properties properties) &#123; String prop1 = properties.getProperty("prop1"); String prop2 = properties.getProperty("prop2"); System.out.println(prop1 + "------" + prop2);&#125;setProperties方法。这个方法在Configuration初始化当前的Interceptor时就会执行，这里只是简单的取两个属性进行打印。看plugin方法中我们是用的Plugin的逻辑来实现Mybatis的逻辑的。MyInterceptor类上我们用@Intercepts标记了这是一个Interceptor，然后在@Intercepts中定义了两个@Signature，即两个拦截点。第一个@Signature我们定义了该Interceptor将拦截Executor接口中参数类型为MappedStatement、Object、RowBounds和ResultHandler的query方法；第二个@Signature我们定义了该Interceptor将拦截StatementHandler中参数类型为Connection的prepare方法。intercept方法。这里我们只是简单的打印了一句话，然后调用invocation的proceed方法，使当前方法正常的调用。对于这个拦截器，Mybatis在注册该拦截器的时候就会利用定义好的n个property作为参数调用该拦截器的setProperties方法。之后在新建可拦截对象的时候会调用该拦截器的plugin方法来决定是返回目标对象本身还是代理对象。对于这个拦截器而言，当Mybatis是要Executor或StatementHandler对象的时候就会返回一个代理对象，其他都是原目标对象本身。然后当Executor代理对象在执行参数类型为MappedStatement、Object、RowBounds和ResultHandler的query方法或StatementHandler代理对象在执行参数类型为Connection的prepare方法时就会触发当前的拦截器的intercept方法进行拦截，而执行这两个接口对象的其他方法时都只是做一个简单的代理。注册拦截器是通过在Mybatis配置文件中plugins元素下的plugin元素来进行的。一个plugin对应着一个拦截器，在plugin元素下面我们可以指定若干个property子元素。Mybatis在注册定义的拦截器时会先把对应拦截器下面的所有property通过Interceptor的setProperties方法注入给对应的拦截器。所以，我们可以这样来注册我们在前面定义的MyInterceptor：123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;properties resource="config/jdbc.properties"&gt;&lt;/properties&gt; &lt;typeAliases&gt; &lt;package name="com.tiantian.mybatis.model"/&gt; &lt;/typeAliases&gt; &lt;plugins&gt; &lt;plugin interceptor="com.tiantian.mybatis.interceptor.MyInterceptor"&gt; &lt;property name="prop1" value="prop1"/&gt; &lt;property name="prop2" value="prop2"/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="com/tiantian/mybatis/mapper/UserMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt;Mybatis拦截器有四种类型的接口:ExecutorStatementHandlerParameterHandlerResultSetHandler以上四种类型的接口是在Mybatis的Configuration中写死了的，如果要支持拦截其他接口就需要我们重写Mybatis的Configuration。Mybatis可以对这四个接口中所有的方法进行拦截。拦截器应用分页场景我们知道要利用JDBC对数据库进行操作就必须要有一个对应的Statement对象。实现思路Mybatis在执行Sql语句前也会产生一个包含Sql语句的Statement对象，而且对应的Sql语句是在Statement之前产生的，所以我们就可以在它成Statement之前对用来生成Statement的Sql语句下手。在Mybatis中Statement语句是通过RoutingStatementHandler对象的prepare方法生成的。所以利用拦截器实现Mybatis分页的一个思路就是拦截StatementHandler接口的prepare方法，然后在拦截器方法中把Sql语句改成对应的分页查询Sql语句，之后再调用StatementHandler对象的prepare方法，即调用invocation.proceed()。更改Sql语句这个看起来很简单，而事实上来说的话就没那么直观，因为包括sql等其他属性在内的多个属性都没有对应的方法可以直接取到，它们对外部都是封闭的，是对象的私有属性，所以这里就需要引入反射机制来获取或者更改对象的私有属性的值了。对于分页而言，在拦截器里面我们常常还需要做的一个操作就是统计满足当前条件的记录一共有多少，这是通过获取到了原始的Sql语句后，把它改为对应的统计语句再利用Mybatis封装好的参数和设置参数的功能把Sql语句中的参数进行替换，之后再执行查询记录数的Sql语句进行总记录数的统计。具体实现先来看一个我们对分页操作封装的一个实体类Page。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.HashMap;import java.util.List;import java.util.Map; /** * 对分页的基本数据进行一个简单的封装 */public class Page&lt;T&gt; &#123; private int pageNo = 1;//页码，默认是第一页 private int pageSize = 15;//每页显示的记录数，默认是15 private int totalRecord;//总记录数 private int totalPage;//总页数 private List&lt;T&gt; results;//对应的当前页记录 private Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;();//其他的参数我们把它分装成一个Map对象 public int getPageNo() &#123; return pageNo; &#125; public void setPageNo(int pageNo) &#123; this.pageNo = pageNo; &#125; public int getPageSize() &#123; return pageSize; &#125; public void setPageSize(int pageSize) &#123; this.pageSize = pageSize; &#125; public int getTotalRecord() &#123; return totalRecord; &#125; public void setTotalRecord(int totalRecord) &#123; this.totalRecord = totalRecord; //在设置总页数的时候计算出对应的总页数，在下面的三目运算中加法拥有更高的优先级，所以最后可以不加括号。 int totalPage = totalRecord%pageSize==0 ? totalRecord/pageSize : totalRecord/pageSize + 1; this.setTotalPage(totalPage); &#125; public int getTotalPage() &#123; return totalPage; &#125; public void setTotalPage(int totalPage) &#123; this.totalPage = totalPage; &#125; public List&lt;T&gt; getResults() &#123; return results; &#125; public void setResults(List&lt;T&gt; results) &#123; this.results = results; &#125; public Map&lt;String, Object&gt; getParams() &#123; return params; &#125; public void setParams(Map&lt;String, Object&gt; params) &#123; this.params = params; &#125; @Override public String toString() &#123; StringBuilder builder = new StringBuilder(); builder.append("Page [pageNo=").append(pageNo).append(", pageSize=") .append(pageSize).append(", results=").append(results).append( ", totalPage=").append(totalPage).append( ", totalRecord=").append(totalRecord).append("]"); return builder.toString(); &#125; &#125;对于需要进行分页的Mapper映射，我们会给它传一个Page对象作为参数，我们可以看到Page对象里面包括了一些分页的基本信息，这些信息我们可以在拦截器里面用到，然后我们把除分页的基本信息以外的其他参数用一个Map对象进行包装，这样在Mapper映射语句中的其他参数就可以从Map中取值。接着来看一下我们的PageInterceptor的定义。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278 package com.tiantian.mybatis.interceptor; import java.lang.reflect.Field; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.util.List; import java.util.Properties; import org.apache.ibatis.executor.parameter.ParameterHandler; import org.apache.ibatis.executor.statement.RoutingStatementHandler; import org.apache.ibatis.executor.statement.StatementHandler; import org.apache.ibatis.mapping.BoundSql; import org.apache.ibatis.mapping.MappedStatement; import org.apache.ibatis.mapping.ParameterMapping; import org.apache.ibatis.plugin.Interceptor; import org.apache.ibatis.plugin.Intercepts; import org.apache.ibatis.plugin.Invocation; import org.apache.ibatis.plugin.Plugin; import org.apache.ibatis.plugin.Signature; import org.apache.ibatis.scripting.defaults.DefaultParameterHandler; import com.tiantian.mybatis.model.Page; /** * * 分页拦截器，用于拦截需要进行分页查询的操作，然后对其进行分页处理。 * 利用拦截器实现Mybatis分页的原理： * 要利用JDBC对数据库进行操作就必须要有一个对应的Statement对象，Mybatis在执行Sql语句前就会产生一个包含Sql语句的Statement对象，而且对应的Sql语句 * 是在Statement之前产生的，所以我们就可以在它生成Statement之前对用来生成Statement的Sql语句下手。在Mybatis中Statement语句是通过RoutingStatementHandler对象的 * prepare方法生成的。所以利用拦截器实现Mybatis分页的一个思路就是拦截StatementHandler接口的prepare方法，然后在拦截器方法中把Sql语句改成对应的分页查询Sql语句，之后再调用 * StatementHandler对象的prepare方法，即调用invocation.proceed()。 * 对于分页而言，在拦截器里面我们还需要做的一个操作就是统计满足当前条件的记录一共有多少，这是通过获取到了原始的Sql语句后，把它改为对应的统计语句再利用Mybatis封装好的参数和设 * 置参数的功能把Sql语句中的参数进行替换，之后再执行查询记录数的Sql语句进行总记录数的统计。 * */ @Intercepts( &#123; @Signature(method = "prepare", type = StatementHandler.class, args = &#123;Connection.class&#125;) &#125;) public class PageInterceptor implements Interceptor &#123; private String databaseType;//数据库类型，不同的数据库有不同的分页方法 /** * 拦截后要执行的方法 */ public Object intercept(Invocation invocation) throws Throwable &#123; //对于StatementHandler其实只有两个实现类，一个是RoutingStatementHandler，另一个是抽象类BaseStatementHandler， //BaseStatementHandler有三个子类，分别是SimpleStatementHandler，PreparedStatementHandler和CallableStatementHandler， //SimpleStatementHandler是用于处理Statement的，PreparedStatementHandler是处理PreparedStatement的，而CallableStatementHandler是 //处理CallableStatement的。Mybatis在进行Sql语句处理的时候都是建立的RoutingStatementHandler，而在RoutingStatementHandler里面拥有一个 //StatementHandler类型的delegate属性，RoutingStatementHandler会依据Statement的不同建立对应的BaseStatementHandler，即SimpleStatementHandler、 //PreparedStatementHandler或CallableStatementHandler，在RoutingStatementHandler里面所有StatementHandler接口方法的实现都是调用的delegate对应的方法。 //我们在PageInterceptor类上已经用@Signature标记了该Interceptor只拦截StatementHandler接口的prepare方法，又因为Mybatis只有在建立RoutingStatementHandler的时候 //是通过Interceptor的plugin方法进行包裹的，所以我们这里拦截到的目标对象肯定是RoutingStatementHandler对象。 RoutingStatementHandler handler = (RoutingStatementHandler) invocation.getTarget(); //通过反射获取到当前RoutingStatementHandler对象的delegate属性 StatementHandler delegate = (StatementHandler)ReflectUtil.getFieldValue(handler, "delegate"); //获取到当前StatementHandler的 boundSql，这里不管是调用handler.getBoundSql()还是直接调用delegate.getBoundSql()结果是一样的，因为之前已经说过了 //RoutingStatementHandler实现的所有StatementHandler接口方法里面都是调用的delegate对应的方法。 BoundSql boundSql = delegate.getBoundSql(); //拿到当前绑定Sql的参数对象，就是我们在调用对应的Mapper映射语句时所传入的参数对象 Object obj = boundSql.getParameterObject(); //这里我们简单的通过传入的是Page对象就认定它是需要进行分页操作的。 if (obj instanceof Page&lt;?&gt;) &#123; Page&lt;?&gt; page = (Page&lt;?&gt;) obj; //通过反射获取delegate父类BaseStatementHandler的mappedStatement属性 MappedStatement mappedStatement = (MappedStatement)ReflectUtil.getFieldValue(delegate, "mappedStatement"); //拦截到的prepare方法参数是一个Connection对象 Connection connection = (Connection)invocation.getArgs()[0]; //获取当前要执行的Sql语句，也就是我们直接在Mapper映射语句中写的Sql语句 String sql = boundSql.getSql(); //给当前的page参数对象设置总记录数 this.setTotalRecord(page, mappedStatement, connection); //获取分页Sql语句 String pageSql = this.getPageSql(page, sql); //利用反射设置当前BoundSql对应的sql属性为我们建立好的分页Sql语句 ReflectUtil.setFieldValue(boundSql, "sql", pageSql); &#125; return invocation.proceed(); &#125; /** * 拦截器对应的封装原始对象的方法 */ public Object plugin(Object target) &#123; return Plugin.wrap(target, this); &#125; /** * 设置注册拦截器时设定的属性 */ public void setProperties(Properties properties) &#123; this.databaseType = properties.getProperty("databaseType"); &#125; /** * 根据page对象获取对应的分页查询Sql语句，这里只做了两种数据库类型，Mysql和Oracle * 其它的数据库都 没有进行分页 * * @param page 分页对象 * @param sql 原sql语句 * @return */ private String getPageSql(Page&lt;?&gt; page, String sql) &#123; StringBuffer sqlBuffer = new StringBuffer(sql); if ("mysql".equalsIgnoreCase(databaseType)) &#123; return getMysqlPageSql(page, sqlBuffer); &#125; else if ("oracle".equalsIgnoreCase(databaseType)) &#123; return getOraclePageSql(page, sqlBuffer); &#125; return sqlBuffer.toString(); &#125; /** * 获取Mysql数据库的分页查询语句 * @param page 分页对象 * @param sqlBuffer 包含原sql语句的StringBuffer对象 * @return Mysql数据库分页语句 */ private String getMysqlPageSql(Page&lt;?&gt; page, StringBuffer sqlBuffer) &#123; //计算第一条记录的位置，Mysql中记录的位置是从0开始的。 int offset = (page.getPageNo() - 1) * page.getPageSize(); sqlBuffer.append(" limit ").append(offset).append(",").append(page.getPageSize()); return sqlBuffer.toString(); &#125; /** * 获取Oracle数据库的分页查询语句 * @param page 分页对象 * @param sqlBuffer 包含原sql语句的StringBuffer对象 * @return Oracle数据库的分页查询语句 */ private String getOraclePageSql(Page&lt;?&gt; page, StringBuffer sqlBuffer) &#123; //计算第一条记录的位置，Oracle分页是通过rownum进行的，而rownum是从1开始的 int offset = (page.getPageNo() - 1) * page.getPageSize() + 1; sqlBuffer.insert(0, "select u.*, rownum r from (").append(") u where rownum &lt; ").append(offset + page.getPageSize()); sqlBuffer.insert(0, "select * from (").append(") where r &gt;= ").append(offset); //上面的Sql语句拼接之后大概是这个样子： //select * from (select u.*, rownum r from (select * from t_user) u where rownum &lt; 31) where r &gt;= 16 return sqlBuffer.toString(); &#125; /** * 给当前的参数对象page设置总记录数 * * @param page Mapper映射语句对应的参数对象 * @param mappedStatement Mapper映射语句 * @param connection 当前的数据库连接 */ private void setTotalRecord(Page&lt;?&gt; page, MappedStatement mappedStatement, Connection connection) &#123; //获取对应的BoundSql，这个BoundSql其实跟我们利用StatementHandler获取到的BoundSql是同一个对象。 //delegate里面的boundSql也是通过mappedStatement.getBoundSql(paramObj)方法获取到的。 BoundSql boundSql = mappedStatement.getBoundSql(page); //获取到我们自己写在Mapper映射语句中对应的Sql语句 String sql = boundSql.getSql(); //通过查询Sql语句获取到对应的计算总记录数的sql语句 String countSql = this.getCountSql(sql); //通过BoundSql获取对应的参数映射 List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings(); //利用Configuration、查询记录数的Sql语句countSql、参数映射关系parameterMappings和参数对象page建立查询记录数对应的BoundSql对象。 BoundSql countBoundSql = new BoundSql(mappedStatement.getConfiguration(), countSql, parameterMappings, page); //通过mappedStatement、参数对象page和BoundSql对象countBoundSql建立一个用于设定参数的ParameterHandler对象 ParameterHandler parameterHandler = new DefaultParameterHandler(mappedStatement, page, countBoundSql); //通过connection建立一个countSql对应的PreparedStatement对象。 PreparedStatement pstmt = null; ResultSet rs = null; try &#123; pstmt = connection.prepareStatement(countSql); //通过parameterHandler给PreparedStatement对象设置参数 parameterHandler.setParameters(pstmt); //之后就是执行获取总记录数的Sql语句和获取结果了。 rs = pstmt.executeQuery(); if (rs.next()) &#123; int totalRecord = rs.getInt(1); //给当前的参数page对象设置总记录数 page.setTotalRecord(totalRecord); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (rs != null) rs.close(); if (pstmt != null) pstmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 根据原Sql语句获取对应的查询总记录数的Sql语句 * @param sql * @return */ private String getCountSql(String sql) &#123; int index = sql.indexOf("from"); return "select count(*) " + sql.substring(index); &#125; /** * 利用反射进行操作的一个工具类 * */ private static class ReflectUtil &#123; /** * 利用反射获取指定对象的指定属性 * @param obj 目标对象 * @param fieldName 目标属性 * @return 目标属性的值 */ public static Object getFieldValue(Object obj, String fieldName) &#123; Object result = null; Field field = ReflectUtil.getField(obj, fieldName); if (field != null) &#123; field.setAccessible(true); try &#123; result = field.get(obj); &#125; catch (IllegalArgumentException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return result; &#125; /** * 利用反射获取指定对象里面的指定属性 * @param obj 目标对象 * @param fieldName 目标属性 * @return 目标字段 */ private static Field getField(Object obj, String fieldName) &#123; Field field = null; for (Class&lt;?&gt; clazz=obj.getClass(); clazz != Object.class; clazz=clazz.getSuperclass()) &#123; try &#123; field = clazz.getDeclaredField(fieldName); break; &#125; catch (NoSuchFieldException e) &#123; //这里不用做处理，子类没有该字段可能对应的父类有，都没有就返回null。 &#125; &#125; return field; &#125; /** * 利用反射设置指定对象的指定属性为指定的值 * @param obj 目标对象 * @param fieldName 目标属性 * @param fieldValue 目标值 */ public static void setFieldValue(Object obj, String fieldName, String fieldValue) &#123; Field field = ReflectUtil.getField(obj, fieldName); if (field != null) &#123; try &#123; field.setAccessible(true); field.set(obj, fieldValue); &#125; catch (IllegalArgumentException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;mybatis 配置拦截器1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;properties resource="config/jdbc.properties"&gt;&lt;/properties&gt; &lt;typeAliases&gt; &lt;package name="com.tiantian.mybatis.model"/&gt; &lt;/typeAliases&gt; &lt;plugins&gt; &lt;plugin interceptor="com.tiantian.mybatis.interceptor.PageInterceptor"&gt; &lt;property name="databaseType" value="Oracle"/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="com/tiantian/mybatis/mapper/UserMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt;测试代码1234567891011SqlSession sqlSession = sqlSessionFactory.openSession();try &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); Page&lt;User&gt; page = new Page&lt;User&gt;(); page.setPageNo(2); List&lt;User&gt; users = userMapper.findPage(page); page.setResults(users); System.out.println(page);&#125; finally &#123; sqlSession.close();&#125;参考:MyBatis拦截器动态修改SQL语句及参数值（场景：查询中字段值中特殊字符自动转义）mybatise自定义插件或者叫mybatise拦截器，动态修改sql语句MyBatis源码剖析 - MyBatis 插件之拦截器（Interceptor）实现原理]]></content>
      <categories>
        <category>java web</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集成mybatis]]></title>
    <url>%2F2019%2F01%2F24%2Fjava-integration-mybatis.html</url>
    <content type="text"><![CDATA[引言MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。其他的ORM框架还有hibernate、SpringJdbcTemplate等。他们直接的区别可以参考Mybaits-Java ORM来源于历史、Hibernate和MyBatis比较。集成mybatis添加pom依赖12345678910&lt;dependency&gt; &lt;groupId&gt;postgresql&lt;/groupId&gt; &lt;artifactId&gt;postgresql&lt;/artifactId&gt; &lt;version&gt;9.2-1002.jdbc4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.3&lt;/version&gt;&lt;/dependency&gt;添加mybatis配置在src目录下新建mybatis-config.xml文件,文件内容如下：12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;&lt;settings&gt; &lt;!-- changes from the defaults for testing --&gt; &lt;setting name="cacheEnabled" value="false" /&gt; &lt;setting name="useGeneratedKeys" value="true" /&gt; &lt;setting name="defaultExecutorType" value="REUSE" /&gt;&lt;/settings&gt;&lt;typeAliases&gt; &lt;typeAlias alias="User" type="com.thunisoft.bean.User" /&gt;&lt;/typeAliases&gt;&lt;!-- postgresql --&gt;&lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="jdbc" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="org.postgresql.Driver" /&gt; &lt;property name="url" value="jdbc:postgresql://localhost:5432/test?charSet=utf-8" /&gt; &lt;property name="username" value="数据库用户名" /&gt; &lt;property name="password" value="数据库密码" /&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt;&lt;!-- 配置mapper.xml 路径--&gt;&lt;mappers&gt; &lt;mapper resource="com/thunisoft/mapper/UserMapper.xml" /&gt;&lt;/mappers&gt;&lt;/configuration&gt;编写mapper.xml和mapper.java文件以下只列出mapper.xml文件,mapper.java是接口 使用@mapper进行声明。123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.thunisoft.mapper.UserMapper"&gt;&lt;!-- 这里namespace必须是UserMapper接口的路径” --&gt;&lt;insert id="insertUser" parameterType="User"&gt; insert into test.t_user(name,age) values(#&#123;name&#125;,#&#123;age&#125;) &lt;!-- 这里sql结尾不能加分号，否则报“ORA-00911”的错误 --&gt;&lt;/insert&gt;&lt;!-- 这里的id必须和UserMapper接口中的接口方法名相同 --&gt;&lt;select id="getUser" resultType="User" parameterType="java.lang.String"&gt; select * from test.t_user where name=#&#123;name&#125;&lt;/select&gt;&lt;!-- 查询所有的用户 --&gt;&lt;select id="getAllUsers" resultType="User"&gt; select * from test.t_user&lt;/select&gt;&lt;/mapper&gt;使用mapper获取一个sqlSessionFactory对象12345678String resource = "mybatis-config.xml";Reader reader = null;try &#123; reader = Resources.getResourceAsReader(resource);&#125; catch (IOException e) &#123; logger.error(e.getMessage());&#125;sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);使用sqlSesstionFactory对象生成sqlSession12345678910SqlSession sqlSession = sqlSessionFactory.openSession(); try &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = new User("lisi", new Integer(25)); userMapper.insertUser(user); // 这里一定要提交，不然数据进不去数据库中 执行事务 sqlSession.commit(); &#125; finally &#123; sqlSession.close(); &#125;ps： mysql数据库集成mybatis和postgresql集成类似。配置如下:12345678910111213&lt;!-- mysql --&gt;&lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="jdbc" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis_test" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="root" /&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt;mysql的pom文件123456&lt;!-- mysql --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.26&lt;/version&gt;&lt;/dependency&gt;Mybatis有个代码生成工具，生成的代码里面有mapper.xml文件，mapper.xml中的sql语句会用parameterType这个属性， 而这个值可能是我们自定义的对象， 此时，如果没有typealiases，我们就需要为parameterType指定全路径：如果没有别名需要指定的全路径太麻烦 所以可以采用以下的方式来指定报名。123456789&lt;typeAliases&gt; &lt;!-- 通过package, 可以直接指定package的名字， mybatis会自动扫描你指定包下面的javabean, 并且默认设置一个别名，默认的名字为： javabean 的首字母小写的非限定类名来作为它的别名。 也可在javabean 加上注解@Alias 来自定义别名， 例如： @Alias(user) &lt;package name="com.dy.entity"/&gt; --&gt; &lt;typeAlias alias="UserEntity" type="com.dy.entity.User"/&gt; &lt;/typeAliases&gt;参考文章:MyBatis中typealiases的使用Mybatis3简单使用（PostgreSQL)]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卸载ie9~ie11的命令]]></title>
    <url>%2F2019%2F01%2F24%2Funinstall-ie9~ie11-commands.html</url>
    <content type="text"><![CDATA[引言卸载windows中默认安装的浏览器，需要删除windows的更新包，在控制面板的程序中找到浏览器的更新包然后将其卸载是一件比较麻烦的事。下面介绍一种使用命令行卸载ie9~11的命令。具体命令执行命令的前提是:必须登陆管理员账户或者拥有管理员权限。ie9 卸载1FORFILES /P %WINDIR%\servicing\Packages /M Microsoft-Windows-InternetExplorer-*9.*.mum /c &quot;cmd /c echo Uninstalling package @fname &amp;&amp; start /w pkgmgr /up:@fname /quiet /norestartie 10 卸载1FORFILES /P %WINDIR%\servicing\Packages /M Microsoft-Windows-InternetExplorer-*10.*.mum /c &quot;cmd /c echo Uninstalling package @fname &amp;&amp; start /w pkgmgr /up:@fname /quiet /norestartie11 卸载1FORFILES /P %WINDIR%\servicing\Packages /M Microsoft-Windows-InternetExplorer-*11.*.mum /c &quot;cmd /c echo Uninstalling package @fname &amp;&amp; start /w pkgmgr /up:@fname /quiet /norestartps： 以上命令执行完，必须重新电脑才能生效。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集成阿里巴巴durid]]></title>
    <url>%2F2019%2F01%2F24%2Fintegrating-alibaba-durid.html</url>
    <content type="text"><![CDATA[引言durid是阿里巴巴公司开发的数据库驱动，集成此驱动可以监控java web项目的运行状态和sql执行状态。集成过程引入durid pom12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt;&lt;/dependency&gt;spring-context中配置数据源1234567891011121314151617181920&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;!-- 配置监控统计拦截的filters 这个表示此数据源是否加入监控--&gt; &lt;property name="initialSize" value="$&#123;cpool.minPoolSize&#125;"/&gt; &lt;property name="maxActive" value="$&#123;cpool.maxPoolSize&#125;"/&gt; &lt;property name="minIdle" value="$&#123;cpool.minPoolSize&#125;"/&gt; &lt;!-- 如果不配置这一项，后台不会显示监控的sql--&gt; &lt;property name="filters" value="stat" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name="maxWait" value="$&#123;cpool.checkoutTimeout&#125;" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="60000" /&gt; &lt;property name="minEvictableIdleTimeMillis" value="300000" /&gt; &lt;property name="validationQuery" value="SELECT 'x'" /&gt; &lt;property name="testWhileIdle" value="true" /&gt; &lt;property name="testOnBorrow" value="false" /&gt; &lt;property name="testOnReturn" value="false" /&gt;&lt;/bean&gt;web.xml中配置拦截器1234567891011121314151617181920&lt;filter&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.alibaba.druid.support.http.WebStatFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;exclusions&lt;/param-name&gt; &lt;param-value&gt;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;ps： 其他durid配置请查询durid驱动文档说明。自行google。]]></content>
      <categories>
        <category>java web</category>
      </categories>
      <tags>
        <tag>durid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat配置https启动出现 No Certificate file specified or invalid file format异常]]></title>
    <url>%2F2019%2F01%2F24%2Fno-certificate-file-specifier-or-invalid-file-format-exception-occurred-in-tomcat-configuration-https-startup.html</url>
    <content type="text"><![CDATA[引言tomcat配置https启动出现 No Certificate file specified or invalid file format异常,以下是具体的原因和解决办法。具体配置12345&lt;Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true" maxThreads="150" scheme="https" secure="true" clientAuth="false" sslProtocol="TLS" keystoreFile="D:/Tomcat6/server.keystore" keystorePass="changeit" /&gt;报错信息上面为tomcat的SSL配置。 但是启动的时候报”No Certificate file specified or invalid file format”异常，完整的启动信息如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293942012-4-28 9:17:07 org.apache.catalina.core.AprLifecycleListener init信息: Loaded APR based Apache Tomcat Native library 1.1.20.2012-4-28 9:17:07 org.apache.catalina.core.AprLifecycleListener init信息: APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true].2012-4-28 9:17:07 org.apache.catalina.startup.SetAllPropertiesRule begin警告: [SetAllPropertiesRule]&#123;Server/Service/Connector&#125; Setting property &apos;clientAuth&apos; to &apos;false&apos; did not find a matching property.2012-4-28 9:17:07 org.apache.catalina.startup.SetAllPropertiesRule begin警告: [SetAllPropertiesRule]&#123;Server/Service/Connector&#125; Setting property &apos;keystoreFile&apos; to &apos;D:/Tomcat6/server.keystore&apos; did not find a matching property.2012-4-28 9:17:07 org.apache.catalina.startup.SetAllPropertiesRule begin警告: [SetAllPropertiesRule]&#123;Server/Service/Connector&#125; Setting property &apos;keystorePass&apos; to &apos;changeit&apos; did not find a matching property.2012-4-28 9:17:08 org.apache.coyote.http11.Http11AprProtocol init严重: Error initializing endpointjava.lang.Exception: No Certificate file specified or invalid file formatat org.apache.tomcat.jni.SSLContext.setCertificate(Native Method)at org.apache.tomcat.util.net.AprEndpoint.init(AprEndpoint.java:733)at org.apache.coyote.http11.Http11AprProtocol.init(Http11AprProtocol.java:107)at org.apache.catalina.connector.Connector.initialize(Connector.java:1022)at org.apache.catalina.core.StandardService.initialize(StandardService.java:703)at org.apache.catalina.core.StandardServer.initialize(StandardServer.java:838)at org.apache.catalina.startup.Catalina.load(Catalina.java:538)at org.apache.catalina.startup.Catalina.load(Catalina.java:562)at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)at java.lang.reflect.Method.invoke(Method.java:597)at org.apache.catalina.startup.Bootstrap.load(Bootstrap.java:261)at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:413)2012-4-28 9:17:08 org.apache.catalina.core.StandardService initialize严重: Failed to initialize connector [Connector[HTTP/1.1-8443]]LifecycleException: Protocol handler initialization failed: java.lang.Exception: No Certificate file specified or invalid file formatat org.apache.catalina.connector.Connector.initialize(Connector.java:1024)at org.apache.catalina.core.StandardService.initialize(StandardService.java:703)at org.apache.catalina.core.StandardServer.initialize(StandardServer.java:838)at org.apache.catalina.startup.Catalina.load(Catalina.java:538)at org.apache.catalina.startup.Catalina.load(Catalina.java:562)at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)at java.lang.reflect.Method.invoke(Method.java:597)at org.apache.catalina.startup.Bootstrap.load(Bootstrap.java:261)at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:413)2012-4-28 9:17:08 org.apache.coyote.ajp.AjpAprProtocol init信息: Initializing Coyote AJP/1.3 on ajp-80092012-4-28 9:17:08 org.apache.catalina.startup.Catalina load信息: Initialization processed in 804 ms2012-4-28 9:17:08 org.apache.catalina.core.StandardService start信息: Starting service Catalina2012-4-28 9:17:08 org.apache.catalina.core.StandardEngine start信息: Starting Servlet Engine: Apache Tomcat/6.0.332012-4-28 9:17:08 org.logicalcobwebs.proxool.ProxoolFacade registerConnectionPool信息: Proxool 0.9.1 (23-Aug-2008 11:10)2012-4-28 9:17:08 org.logicalcobwebs.proxool.ConnectionPoolDefinition setAnyProperty警告: Use of proxool.maximum-new-connections is deprecated. Use more descriptive proxool.simultaneous-build-throttle instead.2012-4-28 9:17:08 org.apache.catalina.startup.HostConfig deployDescriptor信息: Deploying configuration descriptor host-manager.xml2012-4-28 9:17:08 org.apache.catalina.startup.HostConfig deployDescriptor信息: Deploying configuration descriptor manager.xml2012-4-28 9:17:08 org.apache.catalina.startup.HostConfig deployDirectory信息: Deploying web application directory docs2012-4-28 9:17:08 org.apache.catalina.startup.HostConfig deployDirectory信息: Deploying web application directory examples2012-4-28 9:17:09 org.apache.coyote.http11.Http11AprProtocol start严重: Error starting endpointjava.lang.Exception: Socket bind failed: [730048] ?????????×???(Э?é/???????/???)????í??at org.apache.tomcat.util.net.AprEndpoint.init(AprEndpoint.java:649)at org.apache.tomcat.util.net.AprEndpoint.start(AprEndpoint.java:766)at org.apache.coyote.http11.Http11AprProtocol.start(Http11AprProtocol.java:137)at org.apache.catalina.connector.Connector.start(Connector.java:1095)at org.apache.catalina.core.StandardService.start(StandardService.java:540)at org.apache.catalina.core.StandardServer.start(StandardServer.java:754)at org.apache.catalina.startup.Catalina.start(Catalina.java:595)at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)at java.lang.reflect.Method.invoke(Method.java:597)at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:289)at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:414)2012-4-28 9:17:09 org.apache.catalina.core.StandardService start严重: Failed to start connector [Connector[HTTP/1.1-8443]]LifecycleException: service.getName(): &quot;Catalina&quot;; Protocol handler start failed: java.lang.Exception: Socket bind failed: [730048] ?????????×???(Э?é/???????/???)????í??at org.apache.catalina.connector.Connector.start(Connector.java:1102)at org.apache.catalina.core.StandardService.start(StandardService.java:540)at org.apache.catalina.core.StandardServer.start(StandardServer.java:754)at org.apache.catalina.startup.Catalina.start(Catalina.java:595)at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)at java.lang.reflect.Method.invoke(Method.java:597)at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:289)at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:414)2012-4-28 9:17:09 org.apache.coyote.ajp.AjpAprProtocol start信息: Starting Coyote AJP/1.3 on ajp-80092012-4-28 9:17:09 org.apache.catalina.startup.Catalina start信息: Server startup in 534 ms解决办法查阅资料，和具体的tomcat版本有关系。tomcat6.0.18在上面的ssl配置不会出现此异常。6.0.33版本中默认启用了APR（APR是通过JNI访问的可移植库，可以提高Tomcat的性能和伸缩性），所以采用传统的配置方式（如下）会报异常 解决办法是采用下面的配置将协议修改成org.apache.coyote.http11.Http11Protocol协议即可。配置如下:12345&lt;Connector port="8443" protocol="org.apache.coyote.http11.Http11Protocol" SSLEnabled="true" maxThreads="150" scheme="https" secure="true" clientAuth="false" sslProtocol="TLS" keystoreFile="D:/Tomcat6/server.keystore" keystorePass="changeit" /&gt;转载：tomcat配置https启动出现”No Certificate file specified or invalid file format”异常]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用java工具keytool生成ssl秘钥文件keystore]]></title>
    <url>%2F2019%2F01%2F24%2Fusing-java-tool-keytool-to-generate-ssl-key-file-keystore.html</url>
    <content type="text"><![CDATA[引言最近在做Mina的开发，通信的时候需要数据加密，而且mina本身支持SSLFilter过滤器，所以可以采用SSL加密的方式对数据进行加密。在进行加密之前，我们需要使用keytool(这个存在于C:\Program Files\Java\jdk1.7.0_65\bin目录下)产生创建keystore和truststore文件。接下来我会为你介绍生成密钥的方法。生成keystore.jsk文件1keytool -genkeypair -alias certificatekey -keyalg RSA -validity 7 -keystore keystore.jks导出凭证文件1keytool -export -alias certificatekey -keystore keystore.jks -rfc -file selfcert.cer将凭证文件导入到truststore文件1keytool -import -alias certificatekey -file selfcert.cer -keystore truststore.jks找到keystore.jks和truststore.jks文件启用tomcat ssh功能找到tomcat/config/server.xml文件，打开找到8443 相关Connector配置如下123456&lt;Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true" maxThreads="150" scheme="https" secure="true" keystoreFile="E:\Tomcat\apache-tomcat-6.0.35\conf\cert\keystore.jks" keystorePass="123456" truststoreFile="E:\Tomcat\apache-tomcat-6.0.35\conf\cert\truststore.jks" truststorePass="123456" clientAuth="true" sslProtocol="TLS" truststoreType="JKS" ciphers="TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA,SSL_RSA_WITH_3DES_EDE_CBC_SHA"/&gt;ps： 此方法我在tomcat6上试过可用，其他tomcat版本没有试过。转载地址：使用keytool生成ssl密钥文件keystore和truststore]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gradle的全局远程仓库配置与gradle的本地仓库]]></title>
    <url>%2F2019%2F01%2F24%2Fglobal-remote-warehouse-configuration-of-gradle-and-local-warehouse-of-gradle.html</url>
    <content type="text"><![CDATA[引言构建，软件生命周期中重要的一环，在现代软件开发过程中，起着越来越重要的作用。现在的构建工具有ant、maven、gradle等。Gradle，一个基于Groovy，更灵活更强大的构建系统，能帮助我们构建更复杂的项目。配置远程仓库地址在C:\Users\用户名.gradle的目录下创建文件init.gradle并添加一下文字，使用阿里云的仓库地址。1234567891011121314151617allprojects&#123; repositories &#123; def REPOSITORY_URL = &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos; all &#123; ArtifactRepository repo -&gt; if(repo instanceof MavenArtifactRepository)&#123; def url = repo.url.toString() if (url.startsWith(&apos;https://repo1.maven.org/maven2&apos;) || url.startsWith(&apos;https://jcenter.bintray.com/&apos;)) &#123; project.logger.lifecycle &quot;Repository $&#123;repo.url&#125; replaced by $REPOSITORY_URL.&quot; remove repo &#125; &#125; &#125; maven &#123; url REPOSITORY_URL &#125; &#125;&#125;配置本地gradle仓库地址设置环境变量：1GRADLE_USER_HOME=已有的且要设为gradle本地仓库的本地目录例子1GRADLE_USER_HOME=D:\我的代码\LibRepo\GradleRepo将文件目录D:\我的代码\LibRepo\GradleRepo 射程本地电脑上的gradle默认的本地仓库，然后执行gradle相关命令，相关缓存的文件将会默认存储在这个目录下。]]></content>
      <categories>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java读取jar包的资源文件的方法(使用maven生成可执行jar包)]]></title>
    <url>%2F2019%2F01%2F24%2Fmethod-of-java-reading-resource-files-of-jar-packages-(using-maven-to-generate-executable-jar-packages).html</url>
    <content type="text"><![CDATA[引言使用ide软件可以读取配置文件的时候采用ClassLoad.getResouce(“/“).getPath()方法读取配置文件，当将项目通过maven打成可执行包以后，在包里面读取不到配置文件。解决办法使用getResourceAsStream()方法来直接获取InputStream对象，不通过文件路径获取。获取完inputstream对象，再将其转成BufferReader，否则后面load的时候还出抛出异常。代码1234567891011121314public Properties loadProperties()&#123; InputStream ips = ImportHelper.class.getResourceAsStream("/config.properties"); Properties properties = new Properties(); BufferedReader br = null; try &#123; br = new BufferedReader(new InputStreamReader(ips, Constant.UNICODE)); properties.load(br); &#125; catch (FileNotFoundException e) &#123; logger.error("文件找不到，请检查配置文件config.properties 是否存在!"); &#125; catch (IOException e) &#123; logger.error(e.getMessage()); &#125; return properties; &#125;]]></content>
      <categories>
        <category>java web</category>
      </categories>
      <tags>
        <tag>maven打包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用maven生成可运行的jar包]]></title>
    <url>%2F2019%2F01%2F24%2Fusing-maven-to-generate-runnable-jar-packages.html</url>
    <content type="text"><![CDATA[引言maven可以使用 mvn package 命令对项目打包，但是使用 java -jar xxx.jar执行jar文件，会出现no main manifest attribute, in xxx.jar的错误。因为是没有配置Main-class下面我们介绍如果使用maven生成可运行jar包jar包能够通过java -xxx.jar执行的条件在jar包中的META-INF/MANIFSET.MF中指定Main-Class。&nbsp;&nbsp;&nbsp;&nbsp;这样才能确定程序的如果在哪里。需要加载到依赖包。有两种方法可以生成可执行jar使用maven-jar-plugin和maven-dependency-plugin插件打包在pom.xml中配置12345678910111213141516171819202122232425262728293031323334353637&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt; &lt;mainClass&gt;com.xxg.Main&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;version&gt;2.10&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-dependencies&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-dependencies&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/lib&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;maven-jar-plugin用于生成META-INF/MANIFEST.MF文件的部分内容com.xxg.Main指定MANIFEST.MF中的Main-Class，addClasspath节点等于true会在MANIFEST.MF加上Class-Path项并配置依赖包，lib/指定依赖包所在目录。例如下面是一个通过maven-jar-plugin插件生成的MANIFEST.MF文件片段：12Class-Path: lib/commons-logging-1.2.jar lib/commons-io-2.4.jar Main-Class: com.xxg.Main只是生成MANIFEST.MF文件还不够，maven-dependency-plugin插件用于将依赖包拷贝到${project.build.directory}/lib指定的位置，即lib目录下。配置完成后，通过mvn package指令打包，会在target目录下生成jar包，并将依赖包拷贝到target/lib目录下。使用maven-assembly-plugin插件打包pom 配置如下12345678910111213141516171819202122232425262728293031&lt;project&gt; &lt;build&gt; &lt;plugins&gt; &lt;!--(start) for package jar with dependencies --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;Main&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;!-- this is used for inheritance merges --&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;!-- bind to the packaging phase --&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!--(end) for package jar with dependencies --&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt;mavan 打包命令1mvn packageps: 当打包过程中，如果某一个jar包下载失败，导致不能打包。那么在本地仓库删除这个jar，然后使用mvn test命令重新编译，在test的过程中会重新下载jar包。在eclipse编辑器打包的时候打包的对应的jdk版本是eclipse的默认jdk版本。如果出现maven和jdk版本不统一可以检查是不是jdk版本不对。参考文章：[Maven]Maven构建可执行的jar包(包含依赖jar包)使用Maven对JAVA程序打包－带主类、带依赖]]></content>
      <categories>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim配置整理]]></title>
    <url>%2F2019%2F01%2F24%2Fvim-configuration-arrangement.html</url>
    <content type="text"><![CDATA[比较完整的vim配置整理window的gvim和linux的vim插件均可以使用。在配置linux vim的时候，注意注释，如果配置不生效，删除配置即可。配置中文字符123456789101112"the chinese encodingset encoding=utf-8set fileencodings=utf-8,chinese,latin-1if has("win32") set fileencoding=chineseelse set fileencoding=utf-8endifsource $VIMRUNTIME/delmenu.vimsource $VIMRUNTIME/menu.vimlanguage messages zh_CN.utf-8set termencoding=gbk配置行号，配色方案等1234567891011set nu! "设置行号colorscheme desert "设置配色方案syntax on "语法高亮syntax enable set nobackup "不生成备份文件set showmatch "设置匹配模式set smartindent "设置只能对齐set ai! "设置自动缩进set fileencodings=utf-8,gbkset ambiwidth=double "设置中文支持set guifont=consolas:h12 "设置字体及大小set mouse=a设置缩进等配置1234567891011121314151617181920212223242526"F4 to toggle highlighting on/offnoremap &lt;F4&gt; :set hlsearch! hlsearch?&lt;CR&gt;"F3 to toggle caseinsensetivenoremap &lt;F3&gt; :set ic! ic?&lt;CR&gt;"设置缩进"set tabstop=4 set softtabstop=4 set shiftwidth=4 set noexpandtab set nu set autoindent set cindent"设置粘贴模式"set paste"显示空格和tab键"set listchars=tab:&gt;-,trail:-"总是显示状态栏"set laststatus=2"显示光标当前位置"set rulerset nocompatible "去除VIM一致性，必须"vundel插件管理配置123456789101112"设置包括vundle和初始化相关的运行时路径"set rtp+=E:\Vim-Vundle\Vundle.vimcall vundle#begin()"启用vundle管理插件，必须"Plugin 'VundleVim/Vundle.vim'"在此增加其他插件，安装的插件需要放在vundle#begin和vundle#end之间""安装github上的插件格式为 Plugin '用户名/插件仓库名'"call vundle#end() filetype plugin indent on "加载vim自带和插件相应的语法和文件类型相关脚本，必须"]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript操作日期与日期格式化]]></title>
    <url>%2F2019%2F01%2F23%2Fjavascript-operation-date-and-date-formatting.html</url>
    <content type="text"><![CDATA[javascript操作日期与日期格式化javascript 获取当前时间1var currentDate = new Date();获取日期中的年月日时分秒12345678910111213currentDate.getYear(); // 获取当前年份(2位)currentDate.getFullYear(); // 获取完整的年份(4位,1970-????)currentDate.getMonth(); // 获取当前月份(0-11,0代表1月)currentDate.getDate(); // 获取当前日(1-31)currentDate.getDay(); // 获取当前星期X(0-6,0代表星期天)currentDate.getTime(); // 获取当前时间(从1970.1.1开始的毫秒数)currentDate.getHours(); // 获取当前小时数(0-23)currentDate.getMinutes(); // 获取当前分钟数(0-59)currentDate.getSeconds(); // 获取当前秒数(0-59)currentDate.getMilliseconds(); // 获取当前毫秒数(0-999)currentDate.toLocaleDateString(); // 获取当前日期var mytime=currentDate.toLocaleTimeString(); // 获取当前时间currentDate.toLocaleString( ); // 获取日期与时间日期格式化采用扩展javascript原型的方式1234567891011121314151617181920212223// 对Date的扩展，将 Date 转化为指定格式的String// 月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符，// 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字)// 例子：// (new Date()).Format("yyyy-MM-dd hh:mm:ss.S") ==&gt; 2006-07-02 08:09:04.423// (new Date()).Format("yyyy-M-d h:m:s.S") ==&gt; 2006-7-2 8:9:4.18Date.prototype.Format = function (fmt) &#123; // author: meizz var o = &#123; "M+": this.getMonth() + 1, // 月份 "d+": this.getDate(), // 日 "h+": this.getHours(), // 小时 "m+": this.getMinutes(), // 分 "s+": this.getSeconds(), // 秒 "q+": Math.floor((this.getMonth() + 3) / 3), // 季度 "S": this.getMilliseconds() // 毫秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp("(" + k + ")").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length))); return fmt;&#125;调用方式12var time1 = new Date().Format("yyyy-MM-dd");var time2 = new Date().Format("yyyy-MM-dd HH:mm:ss");转载于：js获取当前时间的年月日时分秒以及时间的格式化]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下 nodejs的安装与淘宝镜像的配置]]></title>
    <url>%2F2019%2F01%2F23%2Finstallation-of-noejs-under-windows-and-configuration-of-taobao-mirror.html</url>
    <content type="text"><![CDATA[windows下 nodejs的安装与淘宝镜像的配置下载&nbsp;&nbsp;&nbsp;&nbsp;官方地址安装nodejs.exe 文件&nbsp;&nbsp;&nbsp;&nbsp;安装完成校验:12node -vnpm -v建立全局目录1E:\nodejs\node_global设置nodejs的全局目录。所有已全局安装的包都被安装在这。12npm config set cache &quot;E:\nodejs\node_cache&quot;npm config set prefix &quot;E:\nodejs\node_global&quot;设置全局变量&nbsp;&nbsp;&nbsp;&nbsp;1.将用户变量path中C:\Users\Administrator\AppData\Roaming\npm;改成E:\nodejs\node_global&nbsp;&nbsp;&nbsp;&nbsp;2. 在系统变量中 新增变量NODE_PATH,变量值为E:\nodejs\node_global\node_modules&nbsp;&nbsp;&nbsp;&nbsp;3.修改系统变量。path:C:\Program Files\nodejs;E:\nodejs\node_global\node_modules;配置淘宝镜像&nbsp;&nbsp;&nbsp;&nbsp;1.淘宝镜像官网&nbsp;&nbsp;&nbsp;&nbsp;2. 安装cnpm1npm install -g cnpm --registry=https://registry.npm.taobao.org来源：nodejs window下安装与配置淘宝镜像]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css font-family 各名称一览表]]></title>
    <url>%2F2019%2F01%2F23%2Flist-of-names-of-css-font-family.html</url>
    <content type="text"><![CDATA[css font-family 各名称一览表windows常见内置中文字体字体中文名字体英文名字体应用宋体SimSun（浏览器默认）英文名黑体SimHei英文名微软雅黑Microsoft Yahei英文名微软正黑体Microsoft JhengHei英文名楷体KaiTi英文名新宋体NSimSun英文名仿宋FangSong英文名OS X常见内置中文字体字体中文名字体英文名字体应用苹方SimSun（浏览器默认）英文名华文黑体PingFang SC英文名华文楷体STHeiti英文名华文宋体STKaiti英文名华文仿宋STSong英文名华文中宋STFangsong英文名华文琥珀STHupo英文名华文新魏STXinwei英文名华文隶书STLiti英文名华文行楷STXingkai英文名冬青黑体简Hiragino Sans GB英文名兰亭黑-简Lantinghei SC英文名翩翩体-简Hanzipen SC英文名手札体-简Hannotate SC英文名宋体-简Songti SC英文名娃娃体-简Wawati SC英文名魏碑-简Weibei SC英文名行楷-简Xingkai SC英文名雅痞-简简Yapi SC英文名圆体-简Yuanti SC英文名具体的字体参考：CSS font-family 各名称一览表]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扩展jquery监控光标在input的位置]]></title>
    <url>%2F2019%2F01%2F23%2Fextending-jquery-to-monitor-cursor-position-in-input.html</url>
    <content type="text"><![CDATA[扩展jquery监控光标在input的位置业务场景 。当需要监控光标所在的位置的时候jquery实现。1234567891011121314151617//监控光标在input框的位置(function ($, undefined) &#123; $.fn.getCursorPosition = function () &#123; var el = $(this).get(0); var pos = 0; if ('selectionStart' in el) &#123; pos = el.selectionStart; &#125; else if ('selection' in document) &#123; el.focus(); var Sel = document.selection.createRange(); var SelLength = document.selection.createRange().text.length; Sel.moveStart('character', -el.value.length); pos = Sel.text.length - SelLength; &#125; return pos; &#125; &#125;)(jQuery);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[兼容ie8-ie11的阻止表单提交的方法]]></title>
    <url>%2F2019%2F01%2F23%2Fmethod-of-preventing-form-submission-compatible-with-ie8-ie11.html</url>
    <content type="text"><![CDATA[业务场景，当满足条件的时候，才允许提交from表单。javascript有两种方法可以阻止表单默认提交。return false绑定表单的onclick方法，当条件不满足返回false123456789101112&lt;form name="loginForm" action="login.aspx" method="post"&gt; &lt;button type="submit" value="Submit" id="submit"&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;script&gt; var submitBtn = document.getElementById("submit"); submitBtn.onclick = function (event) &#123; alert("preventDefault!"); return false; &#125;; &lt;/script&gt;使用preventDefalut()方法。在标准浏览器中，阻止浏览器默认行为使用event.preventDefalt(),而在IE6~8，使用returnValue属性来实现。123456789101112131415&lt;form name="loginForm" action="login.aspx" method="post"&gt; &lt;button type="submit" value="Submit" id="submit"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt; var submitBtn = document.getElementById("submit"); submitBtn.onclick = function (event) &#123; window.event.returnValue = false; // 兼容IE6~8 // 需要判断浏览器是否支持默认行为，兼容谷歌等 ie9-11的浏览器 if (window.event.preventDefault) &#123; window.event.preventDefault(); &#125; &#125;;&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义alert弹窗]]></title>
    <url>%2F2019%2F01%2F23%2Fcustom-alert-bullet-window.html</url>
    <content type="text"><![CDATA[使用javascript自定义alert弹窗当我们退出的时候需要弹出一个弹出框，询问用户是否退出。如果使用javascript的confirm弹窗，样式不太美观，所以采用了下面的形式更改了系统默认的弹窗。下面是具体的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt; &lt;html lang="zh-cn"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;教你如何更改网页的默认alert弹窗&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 更改系统默认弹窗 --&gt; &lt;script type="text/javascript"&gt; window.alert = function(str) &#123; var shield = document.createElement("DIV"); shield.id = "shield"; shield.style.position = "absolute"; shield.style.left = "50%"; shield.style.top = "50%"; shield.style.width = "280px"; shield.style.height = "150px"; shield.style.marginLeft = "-140px"; shield.style.marginTop = "-110px"; shield.style.zIndex = "25"; var alertFram = document.createElement("DIV"); alertFram.id="alertFram"; alertFram.style.position = "absolute"; alertFram.style.width = "280px"; alertFram.style.height = "150px"; alertFram.style.left = "50%"; alertFram.style.top = "50%"; alertFram.style.marginLeft = "-140px"; alertFram.style.marginTop = "-110px"; alertFram.style.textAlign = "center"; alertFram.style.lineHeight = "150px"; alertFram.style.zIndex = "300"; strHtml = "&lt;ul style=\"list-style:none;margin:0px;padding:0px;width:100%\"&gt;\n"; strHtml += " &lt;li style=\"background:#2f5b7b;text-align:left;padding-left:20px;font-size:14px;font-weight:bold;height:40px;line-height:40px;border:1px solid #2f5b7b;color:white\"&gt;[自定义alert]&lt;/li&gt;\n"; strHtml += " &lt;li style=\"background:#183042;text-align:center;font-size:15px;height:95px;line-height:95px;border-left:1px solid #183042;border-right:1px solid #183042;color:#ffffff\"&gt;"+str+"&lt;/li&gt;\n"; strHtml += " &lt;li style=\"background:#183042;text-align:center;font-weight:bold;height:40px;line-height:40px; border:1px solid #183042;\"&gt;&lt;input type=\"button\" value=\"确 定\" onclick=\"doOk()\" style=\"width:80px;height:28px;background:#3ea1fa;color:white;border:1px solid #3ea1fa;font-size:14px;line-height:27px;outline:none;\"/&gt;&lt;/li&gt;\n"; strHtml += "&lt;/ul&gt;\n"; alertFram.innerHTML = strHtml; document.body.appendChild(alertFram); document.body.appendChild(shield); this.doOk = function()&#123; alertFram.style.display = "none"; shield.style.display = "none"; &#125; alertFram.focus(); document.body.onselectstart = function()&#123;return false;&#125;; &#125; &lt;/script&gt; &lt;script&gt; // 测试 alert alert('自定义弹窗'); &lt;/script&gt; &lt;button onclick="javascript:alert('dddd')"&gt;弹出&lt;/button&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滚动条插件 mCustomScrollbar滚动加载数据]]></title>
    <url>%2F2019%2F01%2F23%2Fscrollbar-plug-in-mcustomscrollbar-scrollbar-scrolls-load-data.html</url>
    <content type="text"><![CDATA[滚动条插件 mCustomScrollbar滚动加载数据mCustomScrollbar滚动条插件地址引入资源文件123&lt;link rel="stylesheet" href="/path/to/jquery.mCustomScrollbar.css" /&gt;&lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="/path/to/jquery.mCustomScrollbar.concat.min.js"&gt;&lt;/script&gt;html文件调用12&lt;div class="classname mCustomScrollbar" data-mcs-theme="minimal-dark"&gt;&lt;/div&gt;其中 classname 是你自己给这个 div 一个样式，比如设置 div 高度等，minimal-dark 是它其中一个样式，可以在 mCustomScrollbar.css 中修改它的样式，比如滚动条的宽度和颜色等。如果要实现滚动获取数据，就不能直接在 html 里直接调用，需要在标签里调用它。12345&lt;script type="text/javascript"&gt; $(".classname").mCustomScrollbar(&#123; theme:"minimal-dark" &#125;);&lt;/script&gt;这个和上面 html 直接调用效果是一样的。使用它的一个回调函数 whileScrolling123456789101112$(".classname").mCustomScrollbar(&#123; theme: 'minimal-dark', callbacks: &#123; whileScrolling: function()&#123; // 只要滚动条滚动，这个函数就会执行 if (this.mcs.topPct &gt;= 90) &#123; // 这表示当滚动条滚动到这个div的90%(当然这个值是可变的)的时候调用下面的代码， $.ajax(&#123; // 用ajax去后台获取数据，并把数据添加到这个div里 &#125;) &#125; &#125; &#125;&#125;)转载：用 mCustomScrollbar 滚动条插件实现滚动更新添加数据]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>mCustomScrollbar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery.ajax向后台传递数组问题]]></title>
    <url>%2F2019%2F01%2F23%2Fjquery.ajax-background-transfer-array-problem.html</url>
    <content type="text"><![CDATA[jQuery.ajax向后台传递数组问题今天重温了一个问题，jQuery.ajax向后台传递一个数组，而在后台接收不到该值前台js方法部分代码如下：123456789101112131415161718//创建一个测试数组 var boxIds = new Array(); boxIds.push(12182); boxIds.push(12183); boxIds.push(12184); //向后台交互 $.ajax(&#123; url: "/xxx", type: "GET", data: &#123; "boxIds": boxIds, "boxType": 0, "time": new Date().getTime() &#125;, success: function(data) &#123; //do sth... &#125; &#125;);后台controller代码（SpringMVC）12345@ResponseBody@RequestMapping(value = "/box/changeLock")public String changeLock(final Long[] boxIds, final int boxType) &#123; return locker_ChangeLockService.changeLock(boxIds, boxType);&#125;观察浏览器中发送的请求，可以发现参数如下12345boxIds[]:12182boxIds[]:12183boxIds[]:12184boxType：0time：xxx可以看到，参数的名字为boxIds[]而不是我们所定义的boxIds，也就是说，当传递数组时，会在我们的数组名称后自动加上”[]”，所以后台接不到。解决办法：设置jQuery.ajax的tradional属性12345678910111213$.ajax(&#123; url: "/xxx", type: "GET", data: &#123; "boxIds": boxIds, "boxType": 0, "time": new Date().getTime() &#125;, traditional: true,//这里设置为true success: function(data) &#123; //do sth... &#125; &#125;);修改之后重新发出请求，观察浏览器12345boxIds:12182boxIds:12183boxIds:12184boxType：0time：xxx这次参数不带”[]”了，并且后台可以成功接收到该数组。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ueditor1.3.6 扩展插件(一键排版)]]></title>
    <url>%2F2019%2F01%2F23%2Fueditor-1.3.6-extension-(one-key-typesetting).html</url>
    <content type="text"><![CDATA[udeitor 百度编辑器现在的ueditor 1.4.3版本可以直接新建文件夹在外部编写相应的插件来实现对百度编辑器的扩展。但是在ueditor1.3.6版本上没有看到有提供这样的扩展。所以在编辑器的内部编写自定义按钮功能。并实现自己的过滤规则。找到ueditor.all.js文件中找到btnCmds 数组中添加 typesetting12345678//为工具栏添加按钮，以下都是统一的按钮触发命令，所以写在一起 var btnCmds = ['undo', 'redo', 'formatmatch', 'bold', 'italic', 'underline', 'fontborder', 'touppercase', 'tolowercase', 'strikethrough', 'subscript', 'superscript', 'source', 'indent', 'outdent', 'blockquote', 'pasteplain', 'pagebreak', 'selectall', 'print','horizontal', 'removeformat', 'time', 'date', 'unlink', 'insertparagraphbeforetable', 'insertrow', 'insertcol', 'mergeright', 'mergedown', 'deleterow', 'deletecol', 'splittorows', 'splittocols', 'splittocells', 'mergecells', 'deletetable', 'drafts','typesetting'];打开ueditor.config.js中找到 toolbars数组，在toolsbars数组中添加 ‘typesetting’12345678910111213toolbars:[ ['fullscreen', 'source', '|', 'undo', 'redo', '|', 'bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript', 'removeformat', 'formatmatch', 'autotypeset', 'blockquote', 'pasteplain', '|', 'forecolor', 'backcolor', 'insertorderedlist', 'insertunorderedlist', 'selectall', 'cleardoc', '|', 'rowspacingtop', 'rowspacingbottom', 'lineheight', '|', 'customstyle', 'paragraph', 'fontfamily', 'fontsize', '|', 'indent', '|', 'justifyleft', 'justifycenter', 'justifyright', 'justifyjustify', '|', '|', 'link', 'unlink', 'anchor', '|', 'insertimage', 'emotion', /*'insertvideo',*/ 'attachment', 'map', /*'gmap',*/ 'insertframe','pagebreak', '|', 'spechars', /*'snapscreen',*/ 'wordimage', '|', 'inserttable', 'deletetable', 'insertparagraphbeforetable', 'insertrow', 'deleterow', 'insertcol', 'deletecol', 'mergecells', 'mergeright', 'mergedown', 'splittocells', 'splittorows', 'splittocols', 'charts', '|', 'print', 'preview', 'searchreplace', 'drafts','typesetting'] ]在ueditor.css中添加插件的样式1234.edui-for-typesetting .edui-icon &#123; /*自定义命令按钮的样式*/ background-position: -236px -76px;&#125;打开zh-cn.js 找到UE.I18N[‘zh-cn’] 在数字中添加 ‘typesetting’:’一键排版’1234567891011121314151617181920UE.I18N['zh-cn'] = &#123; 'labelMap':&#123; 'anchor':'锚点', 'undo':'撤销', 'redo':'重做', 'bold':'加粗', 'indent':'首行缩进', 'snapscreen':'截图', 'italic':'斜体', 'underline':'下划线', 'strikethrough':'删除线', 'subscript':'下标','fontborder':'字符边框', 'superscript':'上标', 'formatmatch':'格式刷', 'source':'源代码', 'blockquote':'引用', 'pasteplain':'纯文本粘贴模式', 'selectall':'全选', 'print':'打印', 'preview':'预览', 'horizontal':'分隔线', 'removeformat':'清除格式', 'time':'时间', 'date':'日期', 'unlink':'取消链接', 'insertrow':'前插入行', 'insertcol':'前插入列', 'mergeright':'右合并单元格', 'mergedown':'下合并单元格', 'deleterow':'删除行', 'deletecol':'删除列', 'splittorows':'拆分成行', 'splittocols':'拆分成列', 'splittocells':'完全拆分单元格', 'mergecells':'合并多个单元格', 'deletetable':'删除表格', 'cleardoc':'清空文档','insertparagraphbeforetable':"表格前插入行",'insertcode':'代码语言','fontfamily':'字体', 'fontsize':'字号', 'paragraph':'段落格式', 'insertimage':'图片', 'edittable':'表格属性','edittd':'单元格属性', 'link':'超链接','emotion':'表情', 'spechars':'特殊字符', 'searchreplace':'查询替换', 'map':'Baidu地图', 'gmap':'Google地图', 'insertvideo':'视频', 'help':'帮助', 'justifyleft':'居左对齐', 'justifyright':'居右对齐', 'justifycenter':'居中对齐', 'justifyjustify':'两端对齐', 'forecolor':'字体颜色', 'backcolor':'背景色', 'insertorderedlist':'有序列表', 'insertunorderedlist':'无序列表', 'fullscreen':'全屏', 'directionalityltr':'从左向右输入', 'directionalityrtl':'从右向左输入', 'rowspacingtop':'段前距', 'rowspacingbottom':'段后距', 'pagebreak':'分页', 'insertframe':'插入Iframe', 'imagenone':'默认', 'imageleft':'左浮动', 'imageright':'右浮动', 'attachment':'附件', 'imagecenter':'居中', 'wordimage':'图片转存', 'lineheight':'行间距','edittip' :'编辑提示','customstyle':'自定义标题', 'autotypeset':'自动排版', 'webapp':'百度应用', 'touppercase':'字母大写', 'tolowercase':'字母小写','background':'背景','template':'模板','scrawl':'涂鸦','music':'音乐',inserttable:'插入表格', 'drafts': '从草稿箱加载', 'charts': '图表','typesetting':'一键排版' &#125;,打开ueditor.all.js 编写自定义插件内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425/** * 一键排版 自定义插件 */ UE.plugins['typesetting'] = function ()&#123; var me = this; //状态 是否进行一键排版操作 0 代表没有进行一键排版 var flag = 0; //用来保存一键排版前的html字符串 var temp = ""; //要在这里编写过滤规则 filterTypeSettingRules 参考了纯文本模式 me.setOpt(&#123; 'filterTypeSettingRules' : function()&#123; /** * 根据获取到的value 设置节点的属性 * @param node 节点 * @param key 秘钥 * @param value 属性值 */ function setAttrValue(node,key,value)&#123; node.setAttr(key,value); &#125; /** * 清除自带样式 不知道ueditor 自带的 UE.dom.domUtils 的静态方法 调用方法不好使 * 所以采用将 制定的样式 style 设置成空的形式 暴力解决问题 * @param node */ function removeAttr(node) &#123; //因为要重置 style 后面还需要获取style属性 所以暂时 不清楚style属性 /*if(node.getAttr("style"))&#123; node.setAttr("style",""); &#125;*/ if(node.getAttr("class"))&#123; node.setAttr("class",""); &#125; if(node.getAttr("className"))&#123; node.setAttr("className",""); &#125; if(node.getAttr("id"))&#123; node.setAttr("id",""); &#125; if(node.getAttr("name"))&#123; node.setAttr("name",""); &#125; if(node.getAttr("width"))&#123; node.setAttr("width",""); &#125; &#125; /** * 根据属性名获取节点值 * @param node * @param key * @param value */ function getNodeAttr(node,key,value)&#123; //如果节点存在 if(node)&#123; return node.getAttr(key,value); &#125; return null; &#125; /** * 获取 node节点的纯文本 * @param node */ function getNodeText (node)&#123; var text = node.innerText(); return text; &#125; /** * 根据传入的节点来处理包含的span元素 包括循环嵌套 * @param node */ function eachChildNode(node)&#123; UE.utils.each(node.getNodesByTagName('span'),function(tNode) &#123; //TODO var name = tNode.tagName; switch (name)&#123; case "span": removeNode(tNode) break; &#125; &#125;); &#125; /** * 判断居中问题 给true|flase 返回值 * 返回 true|false 通过node的center属性或者是style的text-align:属性 * @param node */ function isCenter(node)&#123; //UE.dom.domUtils.getStyle( testNode, "color" ) 这个不知道好不好用 所以采用一种特别的方式来处理 //默认为不居中 var align = false; var temp = node.getAttr("style"); var arg=0; if(typeof(temp)!="undefined"&amp;&amp;temp!=null)&#123; arg = node.getAttr("style").toLowerCase().indexOf("center"); &#125; if(node.getAttr('align')=='center' || arg&gt;0)&#123; align = true; &#125; return align; &#125; function transP(node)&#123; node.tagName = 'p'; node.setStyle(); &#125; /** * 处理标题公共部分 * @param node */ function handleTitle(node)&#123; var text = getNodeText(node); removeAttr(node); //h2 嵌套span元素处理 eachChildNode(node); node.innerText(text); &#125; /** * 处理 h1 * @param node */ function addH1Style(node) &#123; handleTitle(node); //先清除自带的样式，然后在为每一个节点添加样式 node.setAttr("style","font-size: 30px;font-family: 仿宋;color: #4c3339;margin:10px 0 10px 0;font-weight: bold;"); &#125; /** * 处理 h2 * @param node */ function addH2Style(node) &#123; handleTitle(node); node.setAttr("style","font-size: 26px;font-family: 仿宋;color: #4c3339;margin:10px 0 10px 0;font-weight: bold;"); &#125; /** * 处理 h3 * @param node */ function addH3Style(node) &#123; handleTitle(node); node.setAttr("style","font-size: 22px;font-family: 仿宋;color: #4c3339;margin:10px 0 10px 0;font-weight: bold;"); &#125; /** * 处理 h4 * @param node */ function addH4Style(node)&#123; handleTitle(node); node.setAttr("style","font-size: 18px;font-family: 仿宋;color: #4c3339;margin:10px 0 10px 0;font-weight: bold;"); &#125; /** * 处理 h5 * @param node */ function addH5Style(node) &#123; handleTitle(node); node.setAttr("style","font-size: 14px;font-family: 仿宋;color: #4c3339;margin:10px 0 10px 0;font-weight: bold;"); &#125; /** * 处理 h6 * @param node */ function addH6Style(node) &#123; handleTitle(node); node.setAttr("style","font-size: 12px;font-family: 仿宋;color: #4c3339;margin:10px 0 10px 0;font-weight: bold;"); &#125; /** * 处理表格 * @param node */ function addTableStyle(node)&#123; //可以将浏览器中相同的属性获取一样的 TODO var cellspacing = node.getAttr("cellspacing"); var cellpadding = node.getAttr("cellpadding"); var align = node.getAttr("align"); var style = node.getAttr("style"); //将获取到的table属性设置到格式化的表格中。 //为了防止 table表格过宽导致跨出页面宽度 为table 添加一个最大宽度 var otherStyle = "margin:10px 0 10px 0"; setAttrValue(node,"cellspacing",cellspacing); setAttrValue(node,"cellpadding",cellpadding); setAttrValue(node,"align",align); setAttrValue(node,"style",style + otherStyle); &#125; /** * 处理td * @param node */ function addTdStyle(node) &#123; //保留td的样式 var width = node.getAttr("width"); var colspan = node.getAttr("colspan"); var style = node.getAttr("style"); setAttrValue(node, "width", width); setAttrValue(node, "colspan", colspan); setAttrValue(node, "style", style); //td属性不变但是里面的文字有变化 //遍历td节点集合 p和span被覆盖掉了 暂时没有什么好的办法 //处理td下面的节点 怎么做 这里的样式才不会被其他的样式覆盖掉？？ UE.utils.each(node.getNodesByTagName("p span"), function (tNode) &#123; var tagName = tNode.tagName; switch (tagName) &#123; case "p": //对p本身的处理 var pStyle = tNode.getAttr("style"); //这个地方进行 强制处理 如果sytle样式已经 被覆盖掉了。先获取 本身的样式 removeAttr(node); if(typeof(pStyle)!="undefined"&amp;&amp;pStyle!=null)&#123; setAttrValue(tNode, "style", pStyle); &#125; setAttrValue(tNode,"name","tdChild"); /*//p下的文字有嵌套 没啥卵用 UE.utils.each(tNode.getNodesByTagName('span'),function(spanNode)&#123; //判断 是否存在 if(spanNode.tagName=="span")&#123; var spanStyle = spanNode.getAttr("style"); removeAttr(node); if(typeof(spanStyle)!="undefined"&amp;&amp;spanStyle!=null)&#123; setAttrValue(spanNode, "style", spanStyle); &#125; setAttrValue(spanNode,"name","tdChild"); &#125; &#125;); break;*/ case "span": var spanStyle = tNode.getAttr("style"); removeAttr(node); if(typeof(spanStyle)!="undefined"&amp;&amp;spanStyle!=null)&#123; setAttrValue(tNode, "style", spanStyle); &#125; setAttrValue(tNode,"name","tdChild"); break; &#125; &#125;); &#125; /** * 处理tr * @param node */ function addTrStyle(node)&#123; var trStyle = node.getStyle("style"); setAttrValue(node,"style",trStyle); &#125; /** * 处理p * @param node */ function addPStyle(node)&#123; var name = node.getAttr("name"); removeAttr(node); //本身样式暂时不知道怎么处理 暂时先不处理 var addStyle = "font-size: 21px;font-family: 仿宋;color: #4c3339;text-indent: 2em;line-height: 28px;"; if(typeof(name)!="undefined"&amp;&amp;name!=null) &#123; if (name == "tdChild")&#123; return ; &#125; &#125; //如果子标签有img的话 为了给img 居中 设置样式为居中 UE.utils.each(node.getNodesByTagName('img'),function(tNode) &#123; var name = tNode.tagName; switch (name)&#123; case "img": addStyle = addStyle + "text-align:center"; break; &#125; &#125;); if (isCenter(node))&#123; addStyle = addStyle + "text-align:center"; &#125; node.setAttr("style",addStyle) node.setAttr("name","singleP"); &#125; /** * 处理a * @param node */ function addAStyle(node)&#123; removeAttr(node); node.setAttr("style","font-size: 21px;font-family: 仿宋;color: #5779ba;line-height: 28px;text-decoration:none;"); &#125; /** * 处理 span * @param node */ function addSpanStyle(node)&#123; var name = node.getAttr("name"); removeAttr(node); //td 下的p 和span 的冲突处理 if(typeof(name)!="undefined"&amp;&amp;name!=null) &#123; if (name = "tdChild")&#123; return ; &#125; &#125; node.setAttr("style","font-size: 21px;font-family: 仿宋;color: #4c3339;text-indent: 2em;line-height: 28px;"); node.setAttr("name","singSpan"); &#125; /** * 对img进行处理 * @param node */ function addImgStyle(node)&#123; //处理转存word图片的情况 if是word转存 需要处理图片 如果没有将图片上传到服务器 则需要删除元素图片元素节点 //一键排版 对于图片的描述 如果没有上传到服务器上面 那么 对于图片的描述没有办法进行处理，因为这个时候没办法判断 下面的节点是作为图片描述还是 正常的段落 var word_img = node.getAttr("word_img"); if(typeof(word_img)!="undefined"&amp;&amp;word_img!=null)&#123; //清除节点 并且 返回 不做下面的操作 removeNode(node); return ; &#125; var src = node.getAttr("src"); //写死图片样式 没有考虑图片压缩的情况 因为取不到图片的质量 var imgStyle = "text-align:center;max-width:500px;padding:0 200px 0 200px;" node.setAttr("src",src); node.setAttr("style",imgStyle); &#125; function removeNode(node)&#123; node.parentNode.removeChild(node,true) &#125; return &#123; //直接删除及其字节点内容 //'-' : 'script style object iframe embed input select', 'p': addPStyle, 'br':&#123;$:&#123;&#125;&#125;, div: function (node) &#123; alert(node.tagName); var tmpNode, p = UE.uNode.createElement('p'); while (tmpNode = node.firstChild()) &#123; if (tmpNode.type == 'text' || !UE.dom.dtd.$block[tmpNode.tagName]) &#123; p.appendChild(tmpNode); &#125; else &#123; if (p.firstChild()) &#123; node.parentNode.insertBefore(p, node); p = UE.uNode.createElement('p'); &#125; else &#123; node.parentNode.insertBefore(tmpNode, node); &#125; &#125; &#125; if (p.firstChild()) &#123; node.parentNode.insertBefore(p, node); &#125; node.parentNode.removeChild(node); &#125;, ol: removeNode, ul: removeNode, dl:removeNode, dt:removeNode, dd:removeNode, 'li':removeNode, 'a':addAStyle, 'table':addTableStyle, 'tr':addTrStyle, 'td':addTdStyle, 'span':addSpanStyle, //'caption':transP, //'th':transP, //'tr':transP, 'h1':addH1Style,'h2':addH2Style,'h3':addH3Style,'h4':addH4Style,'h5':addH5Style,'h6':addH6Style, 'img':addImgStyle //不清除 表格td的样式 /*'td':function(node)&#123; //没有内容的td直接删掉 var txt = !!node.innerText(); if(txt)&#123; node.parentNode.insertAfter(UE.uNode.createText(' &amp;nbsp; &amp;nbsp;'),node); &#125; node.parentNode.removeChild(node,node.innerText()) &#125;*/ &#125; &#125;() &#125;); me.commands['typesetting'] = &#123; // 暂时不做扩展，不通过传递参数指定排版的位置，选取所有的选区，对所有的内容进行一键排版 execCommand : function(cmdName,style)&#123; //根据编辑器的内容获取uNode节点 调用UE的静态方法 htmlparser var root = UE.htmlparser(me.getContent(),true); //如果内容为空则返回，不进行一键排版 var html = ""; //先将未过滤的字符串存到一个变量里面 var meHtml = me.getContent(); if(me.getContent()=="")&#123; return ; &#125; if(flag==0)&#123; temp = meHtml; html = UE.filterNode(root, me.options.filterTypeSettingRules).toHtml(); flag = 1; &#125;else&#123; //恢复到一键排版前的状态 html = temp; flag = 0; //将temp清空 手动清理占用 temp = ""; &#125; me.setContent(html); &#125;, queryCommandState:function()&#123; return flag == 1?1:0; &#125; &#125;; &#125;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ueditor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用jquery 实现点击页面元素隐藏弹出的弹出框]]></title>
    <url>%2F2019%2F01%2F23%2Fusing-jquery-to-hide-pop-up-boxes-by-clicking-on-page-elements.html</url>
    <content type="text"><![CDATA[使用jquery 点击页面doucment元素，隐藏弹出框12345678910111213 $(document).mouseup( function(a) &#123; if (!$(a.target).isChildAndSelfOf(".dateTimePicker") &amp;&amp;!$(a.target).isChildAndSelfOf("#shield") &amp;&amp;!$(a.target).isChildAndSelfOf("#alertFram")) &#123; $(".timeBox").hide(); &#125; &#125;);// 判断当前元素是否是被筛选元素的子元素或者本身jQuery.fn.isChildAndSelfOf = function(b) &#123; return (this.closest(b).length &gt; 0);&#125;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[postgresql数据库备份]]></title>
    <url>%2F2019%2F01%2F23%2Fpostgresql-database-backup.html</url>
    <content type="text"><![CDATA[postgresql pg_dump dump数据库表 命令123456pg_dump -U sa(用户名) -d abase(数据库名) -f kettle.sql（文件名，默认会保存的postgre sql bin 目录下）。pg_dump -h [db ip] -U [db user name] -s [db name] -n [schema name] &gt; [file path]pg_dump 指定模式的表和数据pg_dump -h 133.3.0.4 -U sa -d abase -n db_sjzx&gt; sjzx20170916.sql -p 5433]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql备份与还原]]></title>
    <url>%2F2019%2F01%2F23%2Fmysql-backup-and-restore.html</url>
    <content type="text"><![CDATA[mysqldump命令导出数据格式：mysqldump -h链接ip -P(大写)端口 -u用户名 -p密码 数据库名&gt;d:XX.sql(路径) 示例：mysqldump -h112.74.192.432 -P3307 -uroot -p8888 htgl &gt;d:\htgl.sql; #导出某个数据库的表－－结构+数据+函数+存储过程 mysqldump -h127.0.0.1 -uroot -p123456 --opt -R htgl &gt;d:\htgl.sql 导出结构不导出数据1mysqldump -d 数据库名 -uroot -p &gt; xxx.sql导出数据不导出结构1mysqldump -t 数据库名 -uroot -p &gt; xxx.sql导出数据和表结构1mysqldump 数据库名 -uroot -p &gt; xxx.sql导出特定表的结构mysqldump -uroot -p -B数据库名 --table 表名 &gt; xxx.sql #mysqldump [OPTIONS] database [tables] 导入格式：mysql -h链接ip -P(大写)端口 -u用户名 -p密码 数据库名 &lt; d:XX.sql(路径) 示例：mysql -uroot -p1234 db1 &lt; c:\a.txt mysqldump -h12323 -P3307 -uroot -p3333 htgl &lt;d:\htgl.sql;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL审计工具Audit插件使用]]></title>
    <url>%2F2019%2F01%2F23%2Fmysql-audit-plug-in.html</url>
    <content type="text"><![CDATA[MySQL审计工具Audit插件使用一、介绍MySQL AUDITMySQL AUDIT Plugin是一个 MySQL安全审计插件，由McAfee提供，设计强调安全性和审计能力。该插件可用作独立审计解决方案，或配置为数据传送给外部监测工具。支持版本为MySQL (5.1, 5.5, 5.6, 5.7)，MariaDB (5.5, 10.0, 10.1) ，Platform (32 or 64 bit)。从Mariadb 10.0版本开始audit插件直接内嵌了，名称为server_audit.so，可以直接加载使用。源码地址：https://github.com/mcafee/mysql-audit/WIKI地址：https://github.com/mcafee/mysql-audit/wiki二进制地址：https://bintray.com/mcafee/mysql-audit-plugin/releasemacfee的mysql audit插件虽然日志信息比较大，对性能影响大，但是如果想要开启审计，那也应该忍受了。二、安装使用MySQL AUDIT下载mysql 对应版本的 audit插件MySQL的插件目录为：复制库文件到MySQL库目录下加载Audit插件查看版本开启Audit功能执行任何语句(默认会记录任何语句)，然后去mysql数据目录查看mysql-audit.json文件(默认为该文件)。当然，我们还可以通过命令查看audit相关的命令其中我们需要关注的参数有：audit_json_file是否开启audit功能。audit_json_log_file记录文件的路径和名称信息。audit_record_cmdsaudit记录的命令，默认为记录所有命令。可以设置为任意dml、dcl、ddl的组合。如：audit_record_cmds=select,insert,delete,update。还可以在线设置set global audit_record_cmds=NULL。(表示记录所有命令)audit_record_objsaudit记录操作的对象，默认为记录所有对象，可以用SET GLOBAL audit_record_objs=NULL设置为默认。也可以指定为下面的格式：audit_record_objs=,test.,mysql.,information_schema.*。audit_whitelist_users用户白名单。三、查看审计数据审计数据一般在mysql的data目录下面。转载来源：MySQL审计工具Audit插件使用]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql权限分离]]></title>
    <url>%2F2019%2F01%2F23%2Fmysql-privilege-separation.html</url>
    <content type="text"><![CDATA[使用root登录mysql数据库安全管理员：use mysql; grant all privileges on *.* to 账号@host identified by &apos;密码&apos;; flush privileges; 将所有的操作权限给此用户账号：代表创建的账号host:为创建的账号允许访问的远程地址。mysql 创建用户并赋权的命令：登录到mysql数据库grant select,insert,update,index,delete... on *.* to 账号@host identified by &apos;密码&apos;; select,insert:权限*.*：第一个”*“代表的是所有数据库，第二个”*“代表的是所有的表。账号：要赋权的账号名密码：此账户的密码host：允许远程访问的ip或者域名。参考：mysql创建用户、赋予指定权限命令]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql远程访问的ip进行限制，指定某个ip可以访问]]></title>
    <url>%2F2019%2F01%2F23%2Fmysql-remote-access-is-restricted-by-ip%2C-specifying-that-an-ip-can-be-accessed.html</url>
    <content type="text"><![CDATA[关闭root账号所有远程ip可以访问的权限。登录mysql数据库;执行如下语句：use mysql; update user set host = &apos;localhost&apos; where user = &apos;root&apos; and host = &apos;%&apos;; flush privileges; 修改以后查询接口： select user,host,password from user; 为指定的终端绑定ip远程访问数据库添加远程ip访问权限use mysql; GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;172.18.32.19&apos; IDENTIFIED BY &apos;password&apos; WITH GRANT OPTION; flush privileges; 172.18.32.19:代表可以远程访问的ip root：代表上述地址可以访问的账号 password:是密码 即，允许来自172.18.32.19的连接并使用root账户和password这个密码进行访问。ALL PRIVILEGES ON 后面的*.*表示所有数据库，即完全访问权限，可以指定为特定数据库。 -- 设置立刻生效。 flush privileges;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改mysql数据库密码的几种方法]]></title>
    <url>%2F2019%2F01%2F23%2Fseveral-methods-of-modifying-mysql-database-password.html</url>
    <content type="text"><![CDATA[修改数据库密码的几种方法：方法1： 用SET PASSWORD命令首先登录MySQL。格式：mysql&gt; set password for 用户名@host = password(&apos;新密码&apos;); 例子：mysql&gt; set password for root@&apos;172.18.32.19&apos; = password(&apos;xxxxxxxx&apos;); 用户名：代表需要修改密码的账号 host：代表和user绑定的ip地址. 方法2：用mysqladmin 不用登录数据库，在mysql的bin目录打开命令行执行即可。（建议）格式：mysqladmin -u用户名 -p旧密码 password 新密码 例子：mysqladmin -uroot -proot password xxxxxx 更改以后可能会出现警告： Using a password on the command line interface can be insecure. 这个警告不影响修改，这个警告为5.6以上mysql的一个策略。 方法3：update表首先登录MySQL。mysql&gt; use mysql; mysql&gt; update user set password=password(&apos;xxx&apos;) where user=&apos;root&apos; and host=&apos;localhost&apos;; mysql&gt; flush privileges;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 配置详解]]></title>
    <url>%2F2019%2F01%2F23%2Fspringboot-configuration-details.html</url>
    <content type="text"><![CDATA[自定义属性配置自定义文件配置多环境化配置外部命令引导总结说点什么SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程。为了让 Spring Boot 更好的生成配置元数据文件，我们需要添加如下依赖（该依赖可以不添加，但是在 IDEA 和 STS 中不会有属性提示，没有提示的配置就跟你用记事本写代码一样苦逼，出个问题弄哭你去），该依赖只会在编译时调用，所以不用担心会对生产造成影响…&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 自定义属性配置demo: name: 1111 age: 1111 Myproperties实现注意:在使用没有properties时要注意读取配置文件属性的类，需要有getter和setter方法，否则读取不到配置文件中的属性值。原因：属性类要生成getter和setter函数，否则映射不成功。使用可以参考：https://blog.csdn.net/yingxiake/article/details/51263071 package com.example.demo.properties; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; /** * Description: * * @author guoyupeng [2018/11/22] */ @Component @ConfigurationProperties(prefix = &quot;demo&quot;) public class MyProperties { private int age; private String name; @Override public String toString() { return &quot;name&quot; + this.name +&quot;\n&quot; + &quot;age&quot;+age ; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } } Controller调用package com.example.demo.controller; import com.example.demo.properties.MyProperties; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * Description: * * @author guoyupeng [2018/11/22] */ @RequestMapping(&quot;properties&quot;) @RestController public class MyPropertiesController { private Logger logger = LoggerFactory.getLogger(getClass()); private MyProperties myProperties; @Autowired public void setMyProperties(MyProperties myProperties) { this.myProperties = myProperties; } @GetMapping(&quot;/1&quot;) public MyProperties myProperties(){ logger.info(&quot;===========================&quot;); logger.info(myProperties.toString()); logger.info(&quot;============================&quot;); return myProperties; } } 自定义文件配置在读取配置文件的类中添加如下注解@PropertySource(&quot;classpath:my2.properties&quot;) 多环境化配置在真实的应用中，常常会有多个环境（如：开发，测试，生产等），不同的环境数据库连接都不一样，这个时候就需要用到spring.profile.active 的强大功能了，它的格式为 application-{profile}.properties，这里的 application 为前缀不能改，{profile} 是我们自己定义的。application-dev.propertiesserver.servlet.context-path=/dev application-test.propertiesserver.servlet.context-path=/test application-prod.propertiesserver.servlet.context-path=/prod 唐亚峰博客springboot配置例子]]></content>
      <categories>
        <category>java web</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
</search>
